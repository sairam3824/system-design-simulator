{"version":3,"sources":["../../../../../../../Documents/Git/system-design/system-design-simulator/src/lib/analytics/time-analytics.ts"],"sourcesContent":["/**\n * Time Analytics Library\n *\n * Time allocation analysis across interview phases.\n * Tracks time spent in each phase and identifies patterns.\n */\n\nimport { prisma } from \"@/lib/prisma\";\n\n// Phase configuration with recommended durations (in seconds)\nconst PHASE_CONFIG = {\n  requirements: { name: \"Requirements Clarification\", recommended: 8 * 60 }, // 8 minutes\n  \"high-level\": { name: \"High-Level Design\", recommended: 12 * 60 }, // 12 minutes\n  \"deep-dive\": { name: \"Deep Dive\", recommended: 12 * 60 }, // 12 minutes\n  scalability: { name: \"Scalability\", recommended: 10 * 60 }, // 10 minutes\n  wrapup: { name: \"Wrap-up\", recommended: 3 * 60 }, // 3 minutes\n} as const;\n\ntype PhaseId = keyof typeof PHASE_CONFIG;\n\n// Types\nexport interface PhaseTimeData {\n  phaseId: string;\n  phaseName: string;\n  recommendedDuration: number; // seconds\n  actualDuration: number; // seconds\n  deviation: number; // percentage from recommended (positive = over, negative = under)\n  isOverTime: boolean;\n  isUnderTime: boolean;\n}\n\nexport interface TimeAnalysis {\n  totalInterviewDuration: number;\n  phases: PhaseTimeData[];\n  averagePhaseAllocation: {\n    [phaseId: string]: {\n      avgDuration: number;\n      avgDeviation: number;\n    };\n  };\n  patterns: {\n    rushesRequirements: boolean;\n    spendsExcessiveOnDeepDive: boolean;\n    neglectsScalability: boolean;\n    skipsWrapup: boolean;\n  };\n  recommendations: string[];\n}\n\nexport interface PhaseTransition {\n  phase: string;\n  startedAt: string;\n  endedAt?: string;\n}\n\n/**\n * Calculate deviation percentage from recommended duration\n */\nexport function calculatePhaseDeviation(actual: number, recommended: number): number {\n  if (recommended === 0) return 0;\n  return ((actual - recommended) / recommended) * 100;\n}\n\n/**\n * Analyze time allocation for a single interview\n */\nexport async function analyzeInterviewTime(interviewId: string): Promise<TimeAnalysis | null> {\n  const interview = await prisma.interview.findUnique({\n    where: { id: interviewId },\n    select: {\n      startedAt: true,\n      endedAt: true,\n      phaseDurations: true,\n      phaseTransitions: true,\n    },\n  });\n\n  if (!interview) return null;\n\n  const phaseDurations: Record<string, number> = interview.phaseDurations\n    ? JSON.parse(interview.phaseDurations)\n    : {};\n\n  // Calculate total duration\n  let totalDuration = 0;\n  if (interview.startedAt && interview.endedAt) {\n    totalDuration = Math.floor(\n      (new Date(interview.endedAt).getTime() - new Date(interview.startedAt).getTime()) / 1000\n    );\n  } else {\n    totalDuration = Object.values(phaseDurations).reduce((sum, d) => sum + d, 0);\n  }\n\n  // Build phase data\n  const phases: PhaseTimeData[] = [];\n\n  for (const [phaseId, config] of Object.entries(PHASE_CONFIG)) {\n    const actualDuration = phaseDurations[phaseId] || 0;\n    const deviation = calculatePhaseDeviation(actualDuration, config.recommended);\n\n    phases.push({\n      phaseId,\n      phaseName: config.name,\n      recommendedDuration: config.recommended,\n      actualDuration,\n      deviation: Number(deviation.toFixed(1)),\n      isOverTime: deviation > 20, // More than 20% over\n      isUnderTime: deviation < -30, // More than 30% under\n    });\n  }\n\n  // Detect patterns\n  const patterns = {\n    rushesRequirements:\n      (phaseDurations.requirements || 0) < PHASE_CONFIG.requirements.recommended * 0.5,\n    spendsExcessiveOnDeepDive:\n      (phaseDurations[\"deep-dive\"] || 0) > PHASE_CONFIG[\"deep-dive\"].recommended * 1.5,\n    neglectsScalability:\n      (phaseDurations.scalability || 0) < PHASE_CONFIG.scalability.recommended * 0.4,\n    skipsWrapup: (phaseDurations.wrapup || 0) < 60, // Less than 1 minute\n  };\n\n  // Generate recommendations\n  const recommendations = generateTimeRecommendations(phases, patterns);\n\n  return {\n    totalInterviewDuration: totalDuration,\n    phases,\n    averagePhaseAllocation: {}, // Single interview doesn't have averages\n    patterns,\n    recommendations,\n  };\n}\n\n/**\n * Analyze time patterns across multiple interviews for a user\n */\nexport async function getUserTimePatterns(userId: string, limit: number = 10): Promise<TimeAnalysis> {\n  const interviews = await prisma.interview.findMany({\n    where: {\n      userId,\n      status: \"completed\",\n      phaseDurations: { not: null },\n    },\n    orderBy: { endedAt: \"desc\" },\n    take: limit,\n    select: {\n      startedAt: true,\n      endedAt: true,\n      phaseDurations: true,\n    },\n  });\n\n  if (interviews.length === 0) {\n    return {\n      totalInterviewDuration: 0,\n      phases: Object.entries(PHASE_CONFIG).map(([phaseId, config]) => ({\n        phaseId,\n        phaseName: config.name,\n        recommendedDuration: config.recommended,\n        actualDuration: 0,\n        deviation: 0,\n        isOverTime: false,\n        isUnderTime: false,\n      })),\n      averagePhaseAllocation: {},\n      patterns: {\n        rushesRequirements: false,\n        spendsExcessiveOnDeepDive: false,\n        neglectsScalability: false,\n        skipsWrapup: false,\n      },\n      recommendations: [\"Complete more interviews to see time pattern analysis.\"],\n    };\n  }\n\n  // Aggregate phase durations\n  const phaseAggregates: Record<string, number[]> = {};\n  let totalDurationSum = 0;\n\n  for (const phaseId of Object.keys(PHASE_CONFIG)) {\n    phaseAggregates[phaseId] = [];\n  }\n\n  for (const interview of interviews) {\n    const phaseDurations: Record<string, number> = interview.phaseDurations\n      ? JSON.parse(interview.phaseDurations)\n      : {};\n\n    // Calculate total duration for this interview\n    if (interview.startedAt && interview.endedAt) {\n      totalDurationSum += Math.floor(\n        (new Date(interview.endedAt).getTime() - new Date(interview.startedAt).getTime()) / 1000\n      );\n    }\n\n    for (const [phaseId] of Object.entries(PHASE_CONFIG)) {\n      if (phaseDurations[phaseId] !== undefined) {\n        phaseAggregates[phaseId].push(phaseDurations[phaseId]);\n      }\n    }\n  }\n\n  // Calculate averages\n  const averagePhaseAllocation: Record<string, { avgDuration: number; avgDeviation: number }> = {};\n  const phases: PhaseTimeData[] = [];\n\n  for (const [phaseId, config] of Object.entries(PHASE_CONFIG)) {\n    const durations = phaseAggregates[phaseId];\n    const avgDuration =\n      durations.length > 0 ? durations.reduce((a, b) => a + b, 0) / durations.length : 0;\n    const avgDeviation = calculatePhaseDeviation(avgDuration, config.recommended);\n\n    averagePhaseAllocation[phaseId] = {\n      avgDuration: Math.round(avgDuration),\n      avgDeviation: Number(avgDeviation.toFixed(1)),\n    };\n\n    phases.push({\n      phaseId,\n      phaseName: config.name,\n      recommendedDuration: config.recommended,\n      actualDuration: Math.round(avgDuration),\n      deviation: Number(avgDeviation.toFixed(1)),\n      isOverTime: avgDeviation > 20,\n      isUnderTime: avgDeviation < -30,\n    });\n  }\n\n  // Detect patterns based on averages\n  const patterns = {\n    rushesRequirements:\n      (averagePhaseAllocation.requirements?.avgDuration || 0) <\n      PHASE_CONFIG.requirements.recommended * 0.5,\n    spendsExcessiveOnDeepDive:\n      (averagePhaseAllocation[\"deep-dive\"]?.avgDuration || 0) >\n      PHASE_CONFIG[\"deep-dive\"].recommended * 1.5,\n    neglectsScalability:\n      (averagePhaseAllocation.scalability?.avgDuration || 0) <\n      PHASE_CONFIG.scalability.recommended * 0.4,\n    skipsWrapup: (averagePhaseAllocation.wrapup?.avgDuration || 0) < 60,\n  };\n\n  // Generate recommendations\n  const recommendations = generateTimeRecommendations(phases, patterns);\n\n  return {\n    totalInterviewDuration: Math.round(totalDurationSum / interviews.length),\n    phases,\n    averagePhaseAllocation,\n    patterns,\n    recommendations,\n  };\n}\n\n/**\n * Generate recommendations based on time patterns\n */\nfunction generateTimeRecommendations(\n  phases: PhaseTimeData[],\n  patterns: TimeAnalysis[\"patterns\"]\n): string[] {\n  const recommendations: string[] = [];\n\n  if (patterns.rushesRequirements) {\n    recommendations.push(\n      \"Spend more time on requirements clarification. Ask about scale, users, and constraints before designing.\"\n    );\n  }\n\n  if (patterns.spendsExcessiveOnDeepDive) {\n    recommendations.push(\n      \"You're spending too much time on deep dive. Keep some time for scalability discussion.\"\n    );\n  }\n\n  if (patterns.neglectsScalability) {\n    recommendations.push(\n      \"Allocate more time to discuss scalability. This is a critical part of system design interviews.\"\n    );\n  }\n\n  if (patterns.skipsWrapup) {\n    recommendations.push(\n      \"Don't skip the wrap-up phase. Use it to summarize your design and address concerns.\"\n    );\n  }\n\n  // Check for specific phase imbalances\n  for (const phase of phases) {\n    if (phase.isOverTime && phase.deviation > 50) {\n      recommendations.push(\n        `You're spending ${Math.round(phase.deviation)}% more time than recommended on ${phase.phaseName}.`\n      );\n    }\n    if (phase.isUnderTime && phase.deviation < -50) {\n      recommendations.push(\n        `You're spending ${Math.abs(Math.round(phase.deviation))}% less time than recommended on ${phase.phaseName}.`\n      );\n    }\n  }\n\n  if (recommendations.length === 0) {\n    recommendations.push(\"Your time allocation is well-balanced across phases. Keep it up!\");\n  }\n\n  return recommendations;\n}\n\n/**\n * Get phase time summary for display\n */\nexport function formatPhaseDuration(seconds: number): string {\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n\n  if (minutes === 0) {\n    return `${remainingSeconds}s`;\n  }\n\n  if (remainingSeconds === 0) {\n    return `${minutes}m`;\n  }\n\n  return `${minutes}m ${remainingSeconds}s`;\n}\n\n/**\n * Calculate phase at a given elapsed time\n */\nexport function calculatePhaseAtTime(elapsedSeconds: number): PhaseId {\n  const totalTime = 45 * 60; // 45 minutes total\n  const remainingTime = totalTime - elapsedSeconds;\n  const minutesLeft = remainingTime / 60;\n\n  if (minutesLeft > 37) return \"requirements\";\n  if (minutesLeft > 25) return \"high-level\";\n  if (minutesLeft > 13) return \"deep-dive\";\n  if (minutesLeft > 3) return \"scalability\";\n  return \"wrapup\";\n}\n"],"names":[],"mappings":"2mDAOA,IAAA,EAAA,EAAA,CAAA,CAAA,yCAGA,IAAM,EAAe,CACnB,aAAc,CAAE,KAAM,6BAA8B,YAAa,GAAO,CAAH,CACrE,aAAc,CAAE,KAAM,oBAAqB,YAAa,GAAQ,EAChE,AAD6D,YAChD,CAAE,KAAM,YAAa,YAAa,GAAQ,EAAH,AACpD,YAAa,CAAE,KAAM,cAAe,YAAa,GAAQ,EAAH,AACtD,OAAQ,CAAE,KAAM,UAAW,YAAa,GAAO,CAAH,AAC9C,EA0CO,SAAS,EAAwB,CAAc,CAAE,CAAmB,SACzE,AAAoB,GAAG,CAAnB,EAA0B,EACtB,CAAC,EAAS,CAAA,CAAW,CAAI,EAAe,GAClD,CAKO,eAAe,EAAqB,CAAmB,EAC5D,IAAM,EAAY,MAAM,EAAA,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,CAClD,MAAO,CAAE,GAAI,CAAY,EACzB,OAAQ,CACN,UAAW,GACX,QAAS,GACT,gBAAgB,EAChB,kBAAkB,CACpB,CACF,GAEA,GAAI,CAAC,EAAW,OAAO,KAEvB,IAAM,EAAyC,EAAU,cAAc,CACnE,KAAK,KAAK,CAAC,EAAU,cAAc,EACnC,CAAC,EAGD,EAAgB,EAElB,EADE,EAAU,SAAS,EAAI,EAAU,OAAO,CAC1B,CAD4B,IACvB,KAAK,CACxB,CAAC,IAAI,KAAK,EAAU,OAAO,EAAE,OAAO,GAAK,IAAI,KAAK,EAAU,SAAS,EAAE,OAAO,EAAA,CAAE,CAAI,KAGtE,OAAO,MAAM,CAAC,GAAgB,MAAM,CAAC,CAAC,EAAK,IAAM,EAAM,EAAG,GAI5E,IAAM,EAA0B,EAAE,CAElC,IAAK,GAAM,CAAC,EAAS,EAAO,GAAI,OAAO,OAAO,CAAC,GAAe,CAC5D,IAAM,EAAiB,CAAc,CAAC,EAAQ,EAAI,EAC5C,EAAY,EAAwB,EAAgB,EAAO,WAAW,EAE5E,EAAO,IAAI,CAAC,SACV,EACA,UAAW,EAAO,IAAI,CACtB,oBAAqB,EAAO,WAAW,gBACvC,EACA,UAAW,OAAO,EAAU,OAAO,CAAC,IACpC,WAAY,EAAY,GACxB,YAAa,EAAY,CAAC,EAC5B,EACF,CAGA,IAAM,EAAW,CACf,mBACE,CAAC,EAAe,YAAY,GAAI,CAAC,CAAI,AAAwC,KAA3B,YAAY,CAAC,WAAW,CAC5E,0BACE,CAAC,CAAc,CAAC,YAAY,GAAI,CAAC,CAA4C,IAAxC,CAAY,CAAC,YAAY,CAAC,WAAW,CAC5E,oBACE,CAAC,EAAe,WAAW,GAAI,CAAC,CAA2C,GAAvC,EAAa,WAAW,CAAC,WAAW,CAC1E,YAA4C,AAA/B,GAAC,GAAe,MAAM,GAAI,CAAC,AAC1C,EAGM,EAAkB,EAA4B,EAAQ,GAE5D,MAAO,CACL,uBAAwB,SACxB,EACA,uBAAwB,CAAC,WACzB,kBACA,CACF,CACF,CAKO,eAAe,EAAoB,CAAc,CAAE,EAAgB,EAAE,EAC1E,IAAM,EAAa,MAAM,EAAA,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CACjD,MAAO,QACL,EACA,OAAQ,YACR,eAAgB,CAAE,IAAK,IAAK,CAC9B,EACA,QAAS,CAAE,QAAS,MAAO,EAC3B,KAAM,EACN,OAAQ,CACN,WAAW,EACX,SAAS,EACT,gBAAgB,CAClB,CACF,GAEA,GAA0B,GAAG,CAAzB,EAAW,MAAM,CACnB,MAAO,CACL,uBAAwB,EACxB,OAAQ,OAAO,OAAO,CAAC,GAAc,GAAG,CAAC,CAAC,CAAC,EAAS,EAAO,GAAK,CAAC,SAC/D,EACA,UAAW,EAAO,IAAI,CACtB,oBAAqB,EAAO,WAAW,CACvC,eAAgB,EAChB,UAAW,EACX,YAAY,EACZ,aAAa,EACf,CAAC,EACD,uBAAwB,CAAC,EACzB,SAAU,CACR,oBAAoB,EACpB,2BAA2B,EAC3B,qBAAqB,EACrB,aAAa,CACf,EACA,gBAAiB,CAAC,yDAAyD,AAC7E,EAIF,IAAM,EAA4C,CAAC,EAC/C,EAAmB,EAEvB,IAAK,IAAM,KAAW,OAAO,IAAI,CAAC,GAChC,CAAe,CAAC,EAAQ,CAAG,EAAE,CAG/B,GAJiD,CAI5C,IAAM,KAAa,EAAY,CAClC,IAAM,EAAyC,EAAU,cAAc,CACnE,KAAK,KAAK,CAAC,EAAU,cAAc,EACnC,CAAC,EASL,IAAK,GAAM,CAAC,EAAQ,GANhB,EAAU,SAAS,EAAI,EAAU,OAAO,EAAE,CAC5C,GAAoB,KAAK,KAAK,CAC5B,CAAC,IAAI,KAAK,EAAU,OAAO,EAAE,OAAO,GAAK,IAAI,KAAK,EAAU,SAAS,EAAE,OAAO,EAAA,CAAE,CAAI,IAAA,EAIhE,OAAO,OAAO,CAAC,SACL,IAA5B,CADgD,AAClC,CAAC,EAAQ,EACzB,CADyC,AAC1B,CAAC,EAAQ,CAAC,IAAI,CAAC,CAAc,CAAC,EAAQ,CAG3D,CAGA,IAAM,EAAwF,CAAC,EACzF,EAA0B,EAAE,CAElC,IAAK,GAAM,CAAC,EAAS,EAAO,GAAI,OAAO,OAAO,CAAC,GAAe,CAC5D,IAAM,EAAY,CAAe,CAAC,EAAQ,CACpC,EACJ,EAAU,MAAM,CAAG,EAAI,EAAU,MAAM,CAAC,CAAC,EAAG,IAAM,EAAI,EAAG,GAAK,EAAU,MAAM,CAAG,EAC7E,EAAe,EAAwB,EAAa,EAAO,WAAW,EAE5E,CAAsB,CAAC,EAAQ,CAAG,CAChC,YAAa,KAAK,KAAK,CAAC,GACxB,aAAc,OAAO,EAAa,OAAO,CAAC,GAC5C,EAEA,EAAO,IAAI,CAAC,SACV,EACA,UAAW,EAAO,IAAI,CACtB,oBAAqB,EAAO,WAAW,CACvC,eAAgB,KAAK,KAAK,CAAC,GAC3B,UAAW,OAAO,EAAa,OAAO,CAAC,IACvC,WAAY,EAAe,GAC3B,YAAa,EAAe,CAAC,EAC/B,EACF,CAGA,IAAM,EAAW,CACf,mBACE,CAAC,EAAuB,YAAY,EAAE,cAAe,CAAC,CACd,GAAxC,EAAa,YAAY,CAAC,WAAW,CACvC,0BACE,CAAC,CAAsB,CAAC,YAAY,EAAE,cAAe,CAAC,CACd,IAAxC,CAAY,CAAC,YAAY,CAAC,WAAW,CACvC,oBACE,CAAC,EAAuB,WAAW,EAAE,cAAe,CAAC,CACd,GAAvC,EAAa,WAAW,CAAC,WAAW,CACtC,YAAa,AAAoD,IAAnD,EAAuB,MAAM,EAAE,cAAe,CAAC,AAC/D,EAGM,EAAkB,EAA4B,EAAQ,GAE5D,MAAO,CACL,uBAAwB,KAAK,KAAK,CAAC,EAAmB,EAAW,MAAM,EACvE,SACA,kCACA,kBACA,CACF,CACF,CAKA,SAAS,EACP,CAAuB,CACvB,CAAkC,EAElC,IAAM,EAA4B,EAAE,CA2BpC,IAAK,IAAM,KAzBP,EAAS,kBAAkB,EAAE,AAC/B,EAAgB,IAAI,CAClB,4GAIA,EAAS,yBAAyB,EAAE,AACtC,EAAgB,IAAI,CAClB,0FAIA,EAAS,mBAAmB,EAAE,AAChC,EAAgB,IAAI,CAClB,mGAIA,EAAS,WAAW,EACtB,AADwB,EACR,IAAI,CAClB,uFAKgB,GACd,EAAM,EADgB,QACN,EAAI,EAAM,SAAS,CAAG,IAAI,AAC5C,EAAgB,IAAI,CAClB,CAAC,gBAAgB,EAAE,KAAK,KAAK,CAAC,EAAM,SAAS,EAAE,gCAAgC,EAAE,EAAM,SAAS,CAAC,CAAC,CAAC,EAGnG,EAAM,WAAW,EAAI,EAAM,SAAS,CAAG,CAAC,IAC1C,AAD8C,EAC9B,IAAI,CAClB,CAAC,gBAAgB,EAAE,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,EAAM,SAAS,GAAG,gCAAgC,EAAE,EAAM,SAAS,CAAC,CAAC,CAAC,EASnH,OAJ+B,GAAG,CAA9B,EAAgB,MAAM,EACxB,EAAgB,IAAI,CAAC,oEAGhB,CACT,CAuBO,SAAS,EAAqB,CAAsB,EAGzD,IAAM,EAAc,CAFF,AACI,KADC,AACW,CAAA,EACE,CAFT,SAIvB,AAAJ,EAAkB,GAAW,CAAP,IAJwB,UAK1C,EAAc,GAAW,CAAP,YAClB,EAAc,GAAW,CAAP,WAClB,EAAc,EAAU,CAAP,aACd,QACT"}