{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/internal/class.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * Please import the `PrismaClient` class from the `client.ts` file instead.\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"./prismaNamespace\"\n\n\nconst config: runtime.GetPrismaClientConfig = {\n  \"previewFeatures\": [],\n  \"clientVersion\": \"7.3.0\",\n  \"engineVersion\": \"9d6ad21cbbceab97458517b147a6a09ff43aa735\",\n  \"activeProvider\": \"sqlite\",\n  \"inlineSchema\": \"// Prisma schema for AI System Design Simulator\\ngenerator client {\\n  provider = \\\"prisma-client\\\"\\n  output   = \\\"../src/generated/prisma\\\"\\n}\\n\\ndatasource db {\\n  provider = \\\"sqlite\\\"\\n}\\n\\nmodel User {\\n  id        String   @id @default(cuid())\\n  email     String   @unique\\n  password  String\\n  name      String?\\n  avatar    String?\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n\\n  profile          Profile?\\n  resumes          Resume[]\\n  interviews       Interview[]\\n  analytics        UserAnalytics?\\n  codingChallenges CodingChallenge[]\\n  codingTests      CodingTest[]\\n}\\n\\nmodel Profile {\\n  id     String @id @default(cuid())\\n  userId String @unique\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  bio             String?\\n  yearsExperience Int?\\n  skills          String  @default(\\\"[]\\\") // JSON array stored as string\\n  targetCompanies String  @default(\\\"[]\\\") // JSON array stored as string\\n  targetRole      String?\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n\\nmodel Resume {\\n  id     String @id @default(cuid())\\n  userId String\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  fileName String\\n  content  String // Full text content of resume\\n  analysis String? // JSON object with AI analysis\\n  filePath String? // Local path to the stored resume file\\n\\n  // ATS Score Data\\n  atsScore       Int? // Total ATS score (0-100)\\n  atsBreakdown   String? // JSON: { contactInfo, structure, experience, keywords, impact }\\n  atsFeedback    String? // JSON array of feedback strings\\n  keywords       String? // JSON array of extracted keywords\\n  softSkills     String? // JSON array of soft skills\\n  predictedRoles String? // JSON array of predicted job roles\\n\\n  uploadedAt DateTime @default(now())\\n  updatedAt  DateTime @updatedAt\\n}\\n\\nmodel Interview {\\n  id     String @id @default(cuid())\\n  userId String\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  topic      String // e.g., \\\"Design Twitter\\\", \\\"Design Uber\\\"\\n  difficulty String @default(\\\"medium\\\") // easy, medium, hard\\n  status     String @default(\\\"pending\\\") // pending, in_progress, completed\\n\\n  startedAt DateTime?\\n  endedAt   DateTime?\\n  createdAt DateTime  @default(now())\\n\\n  // Time tracking for phases\\n  phaseDurations   String? // JSON: { requirements: 480, highLevel: 720 } in seconds\\n  phaseTransitions String? // JSON: [{ phase: \\\"requirements\\\", startedAt: ISO, endedAt: ISO }]\\n\\n  messages Message[]\\n  score    Score?\\n\\n  @@index([userId, status, endedAt])\\n}\\n\\nmodel Message {\\n  id          String    @id @default(cuid())\\n  interviewId String\\n  interview   Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)\\n\\n  role    String // user, assistant, system\\n  content String\\n\\n  timestamp DateTime @default(now())\\n}\\n\\nmodel Score {\\n  id          String    @id @default(cuid())\\n  interviewId String    @unique\\n  interview   Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)\\n\\n  // 6 Industry-Standard FAANG Evaluation Dimensions (1-4 scale)\\n  requirementsClarification Int @default(0)\\n  highLevelDesign           Int @default(0)\\n  detailedDesign            Int @default(0)\\n  scalability               Int @default(0)\\n  tradeoffs                 Int @default(0)\\n  communication             Int @default(0)\\n\\n  // Calculated fields\\n  overallScore Float   @default(0) // Weighted average\\n  passStatus   Boolean @default(false)\\n\\n  // Detailed feedback as JSON\\n  feedback String @default(\\\"{}\\\") // JSON with per-dimension comments\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n\\n// Cached analytics for user performance tracking\\nmodel UserAnalytics {\\n  id     String @id @default(cuid())\\n  userId String @unique\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  // Cached aggregates (updated after each interview)\\n  totalInterviews     Int    @default(0)\\n  completedInterviews Int    @default(0)\\n  avgOverallScore     Float?\\n  passRate            Float?\\n\\n  // Weak/strong areas tracking\\n  weakDimensions   String @default(\\\"[]\\\") // JSON array: [\\\"scalability\\\", \\\"tradeoffs\\\"]\\n  strongDimensions String @default(\\\"[]\\\") // JSON array: [\\\"communication\\\", \\\"requirements\\\"]\\n\\n  // Topic performance\\n  topicStats String @default(\\\"{}\\\") // JSON: { \\\"Design Twitter\\\": { count: 5, avgScore: 2.8 } }\\n\\n  // Trend data\\n  scoreTrend       String   @default(\\\"stable\\\") // \\\"improving\\\" | \\\"stable\\\" | \\\"declining\\\"\\n  lastCalculatedAt DateTime @default(now())\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n\\n// ==================== CODING CHALLENGE MODELS ====================\\n\\n// Predefined problem bank\\nmodel CodingProblem {\\n  id                 String            @id @default(cuid())\\n  title              String\\n  description        String\\n  difficulty         String // easy, medium, hard\\n  category           String // arrays, strings, dp, graphs, trees, etc.\\n  companies          String            @default(\\\"[]\\\") // JSON array of company names\\n  constraints        String            @default(\\\"[]\\\") // JSON array\\n  examples           String            @default(\\\"[]\\\") // JSON [{input, output, explanation}]\\n  testCases          String            @default(\\\"[]\\\") // JSON [{input, expectedOutput, isHidden}]\\n  solutionApproaches String            @default(\\\"[]\\\") // JSON array\\n  starterCode        String            @default(\\\"{}\\\") // JSON {python: \\\"...\\\", java: \\\"...\\\"}\\n  timeLimit          Int               @default(45) // minutes\\n  createdAt          DateTime          @default(now())\\n  updatedAt          DateTime          @updatedAt\\n  challenges         CodingChallenge[]\\n\\n  @@index([difficulty, category])\\n}\\n\\n// User's coding challenge instance\\nmodel CodingChallenge {\\n  id           String                @id @default(cuid())\\n  userId       String\\n  user         User                  @relation(fields: [userId], references: [id], onDelete: Cascade)\\n  problemId    String?\\n  problem      CodingProblem?        @relation(fields: [problemId], references: [id])\\n  testId       String?\\n  test         CodingTest?           @relation(fields: [testId], references: [id], onDelete: Cascade)\\n  title        String\\n  description  String\\n  difficulty   String\\n  category     String\\n  company      String?\\n  language     String // python, java, javascript, cpp, c, csharp, go\\n  visibleTests String                @default(\\\"[]\\\")\\n  hiddenTests  String                @default(\\\"[]\\\")\\n  timeLimit    Int                   @default(45)\\n  status       String                @default(\\\"pending\\\") // pending, in_progress, completed\\n  startedAt    DateTime?\\n  endedAt      DateTime?\\n  starterCode  String?\\n  finalCode    String?\\n  createdAt    DateTime              @default(now())\\n  updatedAt    DateTime              @updatedAt\\n  submissions  ChallengeSubmission[]\\n  score        ChallengeScore?\\n\\n  @@index([userId, status])\\n}\\n\\n// Code submission for evaluation\\nmodel ChallengeSubmission {\\n  id           String          @id @default(cuid())\\n  challengeId  String\\n  challenge    CodingChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)\\n  code         String\\n  language     String\\n  submittedAt  DateTime        @default(now())\\n  evaluation   String?\\n  testResults  String?\\n  isValid      Boolean         @default(false)\\n  errorMessage String?\\n\\n  @@index([challengeId])\\n}\\n\\n// Final score for coding challenge\\nmodel ChallengeScore {\\n  id                 String          @id @default(cuid())\\n  challengeId        String          @unique\\n  challenge          CodingChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)\\n  correctness        Float\\n  efficiency         Float\\n  codeQuality        Float\\n  edgeCases          Float\\n  overallScore       Float\\n  passStatus         Boolean\\n  feedback           String\\n  suggestedApproach  String?\\n  complexityAnalysis String?\\n  createdAt          DateTime        @default(now())\\n}\\n\\n// ==================== CODING TEST MODELS ====================\\n\\nmodel CodingTest {\\n  id         String            @id @default(cuid())\\n  userId     String\\n  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)\\n  challenges CodingChallenge[]\\n  status     String            @default(\\\"pending\\\") // pending, in_progress, completed\\n  startedAt  DateTime?\\n  endedAt    DateTime?\\n  timeLimit  Int // Total minutes for all questions\\n  createdAt  DateTime          @default(now())\\n  updatedAt  DateTime          @updatedAt\\n}\\n\",\n  \"runtimeDataModel\": {\n    \"models\": {},\n    \"enums\": {},\n    \"types\": {}\n  }\n}\n\nconfig.runtimeDataModel = JSON.parse(\"{\\\"models\\\":{\\\"User\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"email\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"password\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"avatar\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"profile\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Profile\\\",\\\"relationName\\\":\\\"ProfileToUser\\\"},{\\\"name\\\":\\\"resumes\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Resume\\\",\\\"relationName\\\":\\\"ResumeToUser\\\"},{\\\"name\\\":\\\"interviews\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Interview\\\",\\\"relationName\\\":\\\"InterviewToUser\\\"},{\\\"name\\\":\\\"analytics\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"UserAnalytics\\\",\\\"relationName\\\":\\\"UserToUserAnalytics\\\"},{\\\"name\\\":\\\"codingChallenges\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"CodingChallengeToUser\\\"},{\\\"name\\\":\\\"codingTests\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingTest\\\",\\\"relationName\\\":\\\"CodingTestToUser\\\"}],\\\"dbName\\\":null},\\\"Profile\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"ProfileToUser\\\"},{\\\"name\\\":\\\"bio\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"yearsExperience\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"skills\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"targetCompanies\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"targetRole\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"Resume\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"ResumeToUser\\\"},{\\\"name\\\":\\\"fileName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"content\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"analysis\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"filePath\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"atsScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"atsBreakdown\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"atsFeedback\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"keywords\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"softSkills\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"predictedRoles\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"uploadedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"Interview\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"InterviewToUser\\\"},{\\\"name\\\":\\\"topic\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"difficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"endedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"phaseDurations\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"phaseTransitions\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"messages\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Message\\\",\\\"relationName\\\":\\\"InterviewToMessage\\\"},{\\\"name\\\":\\\"score\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Score\\\",\\\"relationName\\\":\\\"InterviewToScore\\\"}],\\\"dbName\\\":null},\\\"Message\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interviewId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interview\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Interview\\\",\\\"relationName\\\":\\\"InterviewToMessage\\\"},{\\\"name\\\":\\\"role\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"content\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"timestamp\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"Score\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interviewId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interview\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Interview\\\",\\\"relationName\\\":\\\"InterviewToScore\\\"},{\\\"name\\\":\\\"requirementsClarification\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"highLevelDesign\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"detailedDesign\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"scalability\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"tradeoffs\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"communication\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"overallScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"passStatus\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"feedback\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"UserAnalytics\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"UserToUserAnalytics\\\"},{\\\"name\\\":\\\"totalInterviews\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"completedInterviews\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"avgOverallScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"passRate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"weakDimensions\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"strongDimensions\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"topicStats\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"scoreTrend\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"lastCalculatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"CodingProblem\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"description\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"difficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"companies\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"constraints\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"examples\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"testCases\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"solutionApproaches\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"starterCode\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"timeLimit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"challenges\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingProblem\\\"}],\\\"dbName\\\":null},\\\"CodingChallenge\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"CodingChallengeToUser\\\"},{\\\"name\\\":\\\"problemId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"problem\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingProblem\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingProblem\\\"},{\\\"name\\\":\\\"testId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"test\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingTest\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingTest\\\"},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"description\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"difficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"company\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"language\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"visibleTests\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"hiddenTests\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"timeLimit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"endedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"starterCode\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"finalCode\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"submissions\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"ChallengeSubmission\\\",\\\"relationName\\\":\\\"ChallengeSubmissionToCodingChallenge\\\"},{\\\"name\\\":\\\"score\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"ChallengeScore\\\",\\\"relationName\\\":\\\"ChallengeScoreToCodingChallenge\\\"}],\\\"dbName\\\":null},\\\"ChallengeSubmission\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challengeId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challenge\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"ChallengeSubmissionToCodingChallenge\\\"},{\\\"name\\\":\\\"code\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"language\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"submittedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"evaluation\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"testResults\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"isValid\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"errorMessage\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"}],\\\"dbName\\\":null},\\\"ChallengeScore\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challengeId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challenge\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"ChallengeScoreToCodingChallenge\\\"},{\\\"name\\\":\\\"correctness\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"efficiency\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"codeQuality\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"edgeCases\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"overallScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"passStatus\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"feedback\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"suggestedApproach\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"complexityAnalysis\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"CodingTest\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"CodingTestToUser\\\"},{\\\"name\\\":\\\"challenges\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingTest\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"endedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"timeLimit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null}},\\\"enums\\\":{},\\\"types\\\":{}}\")\n\nasync function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {\n  const { Buffer } = await import('node:buffer')\n  const wasmArray = Buffer.from(wasmBase64, 'base64')\n  return new WebAssembly.Module(wasmArray)\n}\n\nconfig.compilerWasm = {\n  getRuntime: async () => await import(\"@prisma/client/runtime/query_compiler_fast_bg.sqlite.mjs\"),\n\n  getQueryCompilerWasmModule: async () => {\n    const { wasm } = await import(\"@prisma/client/runtime/query_compiler_fast_bg.sqlite.wasm-base64.mjs\")\n    return await decodeBase64AsWasm(wasm)\n  },\n\n  importName: \"./query_compiler_fast_bg.js\"\n}\n\n\n\nexport type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =\n  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never\n\nexport interface PrismaClientConstructor {\n    /**\n   * ## Prisma Client\n   * \n   * Type-safe database client for TypeScript\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Users\n   * const users = await prisma.user.findMany()\n   * ```\n   * \n   * Read more in our [docs](https://pris.ly/d/client).\n   */\n\n  new <\n    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n    LogOpts extends LogOptions<Options> = LogOptions<Options>,\n    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],\n    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>\n}\n\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.user.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\n\nexport interface PrismaClient<\n  in LogOpts extends Prisma.LogLevel = never,\n  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,\n  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): runtime.Types.Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): runtime.Types.Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>\n\n  $extends: runtime.Types.Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.user`: Exposes CRUD operations for the **User** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Users\n    * const users = await prisma.user.findMany()\n    * ```\n    */\n  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Profiles\n    * const profiles = await prisma.profile.findMany()\n    * ```\n    */\n  get profile(): Prisma.ProfileDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.resume`: Exposes CRUD operations for the **Resume** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Resumes\n    * const resumes = await prisma.resume.findMany()\n    * ```\n    */\n  get resume(): Prisma.ResumeDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.interview`: Exposes CRUD operations for the **Interview** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Interviews\n    * const interviews = await prisma.interview.findMany()\n    * ```\n    */\n  get interview(): Prisma.InterviewDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.message`: Exposes CRUD operations for the **Message** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Messages\n    * const messages = await prisma.message.findMany()\n    * ```\n    */\n  get message(): Prisma.MessageDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.score`: Exposes CRUD operations for the **Score** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Scores\n    * const scores = await prisma.score.findMany()\n    * ```\n    */\n  get score(): Prisma.ScoreDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.userAnalytics`: Exposes CRUD operations for the **UserAnalytics** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more UserAnalytics\n    * const userAnalytics = await prisma.userAnalytics.findMany()\n    * ```\n    */\n  get userAnalytics(): Prisma.UserAnalyticsDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.codingProblem`: Exposes CRUD operations for the **CodingProblem** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more CodingProblems\n    * const codingProblems = await prisma.codingProblem.findMany()\n    * ```\n    */\n  get codingProblem(): Prisma.CodingProblemDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.codingChallenge`: Exposes CRUD operations for the **CodingChallenge** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more CodingChallenges\n    * const codingChallenges = await prisma.codingChallenge.findMany()\n    * ```\n    */\n  get codingChallenge(): Prisma.CodingChallengeDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.challengeSubmission`: Exposes CRUD operations for the **ChallengeSubmission** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more ChallengeSubmissions\n    * const challengeSubmissions = await prisma.challengeSubmission.findMany()\n    * ```\n    */\n  get challengeSubmission(): Prisma.ChallengeSubmissionDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.challengeScore`: Exposes CRUD operations for the **ChallengeScore** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more ChallengeScores\n    * const challengeScores = await prisma.challengeScore.findMany()\n    * ```\n    */\n  get challengeScore(): Prisma.ChallengeScoreDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.codingTest`: Exposes CRUD operations for the **CodingTest** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more CodingTests\n    * const codingTests = await prisma.codingTest.findMany()\n    * ```\n    */\n  get codingTest(): Prisma.CodingTestDelegate<ExtArgs, { omit: OmitOpts }>;\n}\n\nexport function getPrismaClientClass(): PrismaClientConstructor {\n  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor\n}\n"],"names":[],"mappings":";;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;CAMC,GAED;;AAIA,MAAM,SAAwC;IAC5C,mBAAmB,EAAE;IACrB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;QAClB,UAAU,CAAC;QACX,SAAS,CAAC;QACV,SAAS,CAAC;IACZ;AACF;AAEA,OAAO,gBAAgB,GAAG,KAAK,KAAK,CAAC;AAErC,eAAe,mBAAmB,UAAkB;IAClD,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,MAAM,YAAY,OAAO,IAAI,CAAC,YAAY;IAC1C,OAAO,IAAI,YAAY,MAAM,CAAC;AAChC;AAEA,OAAO,YAAY,GAAG;IACpB,YAAY,UAAY;IAExB,4BAA4B;QAC1B,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,OAAO,MAAM,mBAAmB;IAClC;IAEA,YAAY;AACd;AA4PO,SAAS;IACd,OAAO,4TAAuB,CAAC;AACjC"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/internal/prismaNamespace.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.3.0\n * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.3.0\",\n  engine: \"9d6ad21cbbceab97458517b147a6a09ff43aa735\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  User: 'User',\n  Profile: 'Profile',\n  Resume: 'Resume',\n  Interview: 'Interview',\n  Message: 'Message',\n  Score: 'Score',\n  UserAnalytics: 'UserAnalytics',\n  CodingProblem: 'CodingProblem',\n  CodingChallenge: 'CodingChallenge',\n  ChallengeSubmission: 'ChallengeSubmission',\n  ChallengeScore: 'ChallengeScore',\n  CodingTest: 'CodingTest'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"user\" | \"profile\" | \"resume\" | \"interview\" | \"message\" | \"score\" | \"userAnalytics\" | \"codingProblem\" | \"codingChallenge\" | \"challengeSubmission\" | \"challengeScore\" | \"codingTest\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    User: {\n      payload: Prisma.$UserPayload<ExtArgs>\n      fields: Prisma.UserFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.UserFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findFirst: {\n          args: Prisma.UserFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findMany: {\n          args: Prisma.UserFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        create: {\n          args: Prisma.UserCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        createMany: {\n          args: Prisma.UserCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        delete: {\n          args: Prisma.UserDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        update: {\n          args: Prisma.UserUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        deleteMany: {\n          args: Prisma.UserDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.UserUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        upsert: {\n          args: Prisma.UserUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        aggregate: {\n          args: Prisma.UserAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>\n        }\n        groupBy: {\n          args: Prisma.UserGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.UserCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number\n        }\n      }\n    }\n    Profile: {\n      payload: Prisma.$ProfilePayload<ExtArgs>\n      fields: Prisma.ProfileFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ProfileFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        findFirst: {\n          args: Prisma.ProfileFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        findMany: {\n          args: Prisma.ProfileFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]\n        }\n        create: {\n          args: Prisma.ProfileCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        createMany: {\n          args: Prisma.ProfileCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]\n        }\n        delete: {\n          args: Prisma.ProfileDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        update: {\n          args: Prisma.ProfileUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        deleteMany: {\n          args: Prisma.ProfileDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ProfileUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]\n        }\n        upsert: {\n          args: Prisma.ProfileUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        aggregate: {\n          args: Prisma.ProfileAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateProfile>\n        }\n        groupBy: {\n          args: Prisma.ProfileGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ProfileGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ProfileCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ProfileCountAggregateOutputType> | number\n        }\n      }\n    }\n    Resume: {\n      payload: Prisma.$ResumePayload<ExtArgs>\n      fields: Prisma.ResumeFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ResumeFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ResumeFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        findFirst: {\n          args: Prisma.ResumeFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ResumeFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        findMany: {\n          args: Prisma.ResumeFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>[]\n        }\n        create: {\n          args: Prisma.ResumeCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        createMany: {\n          args: Prisma.ResumeCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ResumeCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>[]\n        }\n        delete: {\n          args: Prisma.ResumeDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        update: {\n          args: Prisma.ResumeUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        deleteMany: {\n          args: Prisma.ResumeDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ResumeUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ResumeUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>[]\n        }\n        upsert: {\n          args: Prisma.ResumeUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        aggregate: {\n          args: Prisma.ResumeAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateResume>\n        }\n        groupBy: {\n          args: Prisma.ResumeGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ResumeGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ResumeCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ResumeCountAggregateOutputType> | number\n        }\n      }\n    }\n    Interview: {\n      payload: Prisma.$InterviewPayload<ExtArgs>\n      fields: Prisma.InterviewFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.InterviewFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.InterviewFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        findFirst: {\n          args: Prisma.InterviewFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.InterviewFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        findMany: {\n          args: Prisma.InterviewFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>[]\n        }\n        create: {\n          args: Prisma.InterviewCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        createMany: {\n          args: Prisma.InterviewCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.InterviewCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>[]\n        }\n        delete: {\n          args: Prisma.InterviewDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        update: {\n          args: Prisma.InterviewUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        deleteMany: {\n          args: Prisma.InterviewDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.InterviewUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.InterviewUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>[]\n        }\n        upsert: {\n          args: Prisma.InterviewUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        aggregate: {\n          args: Prisma.InterviewAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateInterview>\n        }\n        groupBy: {\n          args: Prisma.InterviewGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InterviewGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.InterviewCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InterviewCountAggregateOutputType> | number\n        }\n      }\n    }\n    Message: {\n      payload: Prisma.$MessagePayload<ExtArgs>\n      fields: Prisma.MessageFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.MessageFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        findFirst: {\n          args: Prisma.MessageFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        findMany: {\n          args: Prisma.MessageFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]\n        }\n        create: {\n          args: Prisma.MessageCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        createMany: {\n          args: Prisma.MessageCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]\n        }\n        delete: {\n          args: Prisma.MessageDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        update: {\n          args: Prisma.MessageUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        deleteMany: {\n          args: Prisma.MessageDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.MessageUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]\n        }\n        upsert: {\n          args: Prisma.MessageUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        aggregate: {\n          args: Prisma.MessageAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>\n        }\n        groupBy: {\n          args: Prisma.MessageGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.MessageCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number\n        }\n      }\n    }\n    Score: {\n      payload: Prisma.$ScorePayload<ExtArgs>\n      fields: Prisma.ScoreFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ScoreFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ScoreFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        findFirst: {\n          args: Prisma.ScoreFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ScoreFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        findMany: {\n          args: Prisma.ScoreFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>[]\n        }\n        create: {\n          args: Prisma.ScoreCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        createMany: {\n          args: Prisma.ScoreCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ScoreCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>[]\n        }\n        delete: {\n          args: Prisma.ScoreDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        update: {\n          args: Prisma.ScoreUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        deleteMany: {\n          args: Prisma.ScoreDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ScoreUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ScoreUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>[]\n        }\n        upsert: {\n          args: Prisma.ScoreUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        aggregate: {\n          args: Prisma.ScoreAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateScore>\n        }\n        groupBy: {\n          args: Prisma.ScoreGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScoreGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ScoreCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScoreCountAggregateOutputType> | number\n        }\n      }\n    }\n    UserAnalytics: {\n      payload: Prisma.$UserAnalyticsPayload<ExtArgs>\n      fields: Prisma.UserAnalyticsFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.UserAnalyticsFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        findFirst: {\n          args: Prisma.UserAnalyticsFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.UserAnalyticsFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        findMany: {\n          args: Prisma.UserAnalyticsFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]\n        }\n        create: {\n          args: Prisma.UserAnalyticsCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        createMany: {\n          args: Prisma.UserAnalyticsCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.UserAnalyticsCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]\n        }\n        delete: {\n          args: Prisma.UserAnalyticsDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        update: {\n          args: Prisma.UserAnalyticsUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        deleteMany: {\n          args: Prisma.UserAnalyticsDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.UserAnalyticsUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.UserAnalyticsUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]\n        }\n        upsert: {\n          args: Prisma.UserAnalyticsUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        aggregate: {\n          args: Prisma.UserAnalyticsAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateUserAnalytics>\n        }\n        groupBy: {\n          args: Prisma.UserAnalyticsGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserAnalyticsGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.UserAnalyticsCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserAnalyticsCountAggregateOutputType> | number\n        }\n      }\n    }\n    CodingProblem: {\n      payload: Prisma.$CodingProblemPayload<ExtArgs>\n      fields: Prisma.CodingProblemFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.CodingProblemFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.CodingProblemFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        findFirst: {\n          args: Prisma.CodingProblemFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.CodingProblemFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        findMany: {\n          args: Prisma.CodingProblemFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>[]\n        }\n        create: {\n          args: Prisma.CodingProblemCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        createMany: {\n          args: Prisma.CodingProblemCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.CodingProblemCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>[]\n        }\n        delete: {\n          args: Prisma.CodingProblemDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        update: {\n          args: Prisma.CodingProblemUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        deleteMany: {\n          args: Prisma.CodingProblemDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.CodingProblemUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.CodingProblemUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>[]\n        }\n        upsert: {\n          args: Prisma.CodingProblemUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        aggregate: {\n          args: Prisma.CodingProblemAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateCodingProblem>\n        }\n        groupBy: {\n          args: Prisma.CodingProblemGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingProblemGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.CodingProblemCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingProblemCountAggregateOutputType> | number\n        }\n      }\n    }\n    CodingChallenge: {\n      payload: Prisma.$CodingChallengePayload<ExtArgs>\n      fields: Prisma.CodingChallengeFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.CodingChallengeFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.CodingChallengeFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        findFirst: {\n          args: Prisma.CodingChallengeFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.CodingChallengeFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        findMany: {\n          args: Prisma.CodingChallengeFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>[]\n        }\n        create: {\n          args: Prisma.CodingChallengeCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        createMany: {\n          args: Prisma.CodingChallengeCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.CodingChallengeCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>[]\n        }\n        delete: {\n          args: Prisma.CodingChallengeDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        update: {\n          args: Prisma.CodingChallengeUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        deleteMany: {\n          args: Prisma.CodingChallengeDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.CodingChallengeUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.CodingChallengeUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>[]\n        }\n        upsert: {\n          args: Prisma.CodingChallengeUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        aggregate: {\n          args: Prisma.CodingChallengeAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateCodingChallenge>\n        }\n        groupBy: {\n          args: Prisma.CodingChallengeGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingChallengeGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.CodingChallengeCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingChallengeCountAggregateOutputType> | number\n        }\n      }\n    }\n    ChallengeSubmission: {\n      payload: Prisma.$ChallengeSubmissionPayload<ExtArgs>\n      fields: Prisma.ChallengeSubmissionFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ChallengeSubmissionFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ChallengeSubmissionFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        findFirst: {\n          args: Prisma.ChallengeSubmissionFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ChallengeSubmissionFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        findMany: {\n          args: Prisma.ChallengeSubmissionFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[]\n        }\n        create: {\n          args: Prisma.ChallengeSubmissionCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        createMany: {\n          args: Prisma.ChallengeSubmissionCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ChallengeSubmissionCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[]\n        }\n        delete: {\n          args: Prisma.ChallengeSubmissionDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        update: {\n          args: Prisma.ChallengeSubmissionUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        deleteMany: {\n          args: Prisma.ChallengeSubmissionDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ChallengeSubmissionUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ChallengeSubmissionUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[]\n        }\n        upsert: {\n          args: Prisma.ChallengeSubmissionUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        aggregate: {\n          args: Prisma.ChallengeSubmissionAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateChallengeSubmission>\n        }\n        groupBy: {\n          args: Prisma.ChallengeSubmissionGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeSubmissionGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ChallengeSubmissionCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeSubmissionCountAggregateOutputType> | number\n        }\n      }\n    }\n    ChallengeScore: {\n      payload: Prisma.$ChallengeScorePayload<ExtArgs>\n      fields: Prisma.ChallengeScoreFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ChallengeScoreFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ChallengeScoreFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        findFirst: {\n          args: Prisma.ChallengeScoreFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ChallengeScoreFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        findMany: {\n          args: Prisma.ChallengeScoreFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]\n        }\n        create: {\n          args: Prisma.ChallengeScoreCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        createMany: {\n          args: Prisma.ChallengeScoreCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ChallengeScoreCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]\n        }\n        delete: {\n          args: Prisma.ChallengeScoreDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        update: {\n          args: Prisma.ChallengeScoreUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        deleteMany: {\n          args: Prisma.ChallengeScoreDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ChallengeScoreUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ChallengeScoreUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]\n        }\n        upsert: {\n          args: Prisma.ChallengeScoreUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        aggregate: {\n          args: Prisma.ChallengeScoreAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateChallengeScore>\n        }\n        groupBy: {\n          args: Prisma.ChallengeScoreGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeScoreGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ChallengeScoreCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeScoreCountAggregateOutputType> | number\n        }\n      }\n    }\n    CodingTest: {\n      payload: Prisma.$CodingTestPayload<ExtArgs>\n      fields: Prisma.CodingTestFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.CodingTestFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.CodingTestFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        findFirst: {\n          args: Prisma.CodingTestFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.CodingTestFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        findMany: {\n          args: Prisma.CodingTestFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>[]\n        }\n        create: {\n          args: Prisma.CodingTestCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        createMany: {\n          args: Prisma.CodingTestCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.CodingTestCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>[]\n        }\n        delete: {\n          args: Prisma.CodingTestDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        update: {\n          args: Prisma.CodingTestUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        deleteMany: {\n          args: Prisma.CodingTestDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.CodingTestUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.CodingTestUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>[]\n        }\n        upsert: {\n          args: Prisma.CodingTestUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        aggregate: {\n          args: Prisma.CodingTestAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateCodingTest>\n        }\n        groupBy: {\n          args: Prisma.CodingTestGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingTestGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.CodingTestCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingTestCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const UserScalarFieldEnum = {\n  id: 'id',\n  email: 'email',\n  password: 'password',\n  name: 'name',\n  avatar: 'avatar',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]\n\n\nexport const ProfileScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  bio: 'bio',\n  yearsExperience: 'yearsExperience',\n  skills: 'skills',\n  targetCompanies: 'targetCompanies',\n  targetRole: 'targetRole',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]\n\n\nexport const ResumeScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  fileName: 'fileName',\n  content: 'content',\n  analysis: 'analysis',\n  filePath: 'filePath',\n  atsScore: 'atsScore',\n  atsBreakdown: 'atsBreakdown',\n  atsFeedback: 'atsFeedback',\n  keywords: 'keywords',\n  softSkills: 'softSkills',\n  predictedRoles: 'predictedRoles',\n  uploadedAt: 'uploadedAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type ResumeScalarFieldEnum = (typeof ResumeScalarFieldEnum)[keyof typeof ResumeScalarFieldEnum]\n\n\nexport const InterviewScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  topic: 'topic',\n  difficulty: 'difficulty',\n  status: 'status',\n  startedAt: 'startedAt',\n  endedAt: 'endedAt',\n  createdAt: 'createdAt',\n  phaseDurations: 'phaseDurations',\n  phaseTransitions: 'phaseTransitions'\n} as const\n\nexport type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]\n\n\nexport const MessageScalarFieldEnum = {\n  id: 'id',\n  interviewId: 'interviewId',\n  role: 'role',\n  content: 'content',\n  timestamp: 'timestamp'\n} as const\n\nexport type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]\n\n\nexport const ScoreScalarFieldEnum = {\n  id: 'id',\n  interviewId: 'interviewId',\n  requirementsClarification: 'requirementsClarification',\n  highLevelDesign: 'highLevelDesign',\n  detailedDesign: 'detailedDesign',\n  scalability: 'scalability',\n  tradeoffs: 'tradeoffs',\n  communication: 'communication',\n  overallScore: 'overallScore',\n  passStatus: 'passStatus',\n  feedback: 'feedback',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type ScoreScalarFieldEnum = (typeof ScoreScalarFieldEnum)[keyof typeof ScoreScalarFieldEnum]\n\n\nexport const UserAnalyticsScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  totalInterviews: 'totalInterviews',\n  completedInterviews: 'completedInterviews',\n  avgOverallScore: 'avgOverallScore',\n  passRate: 'passRate',\n  weakDimensions: 'weakDimensions',\n  strongDimensions: 'strongDimensions',\n  topicStats: 'topicStats',\n  scoreTrend: 'scoreTrend',\n  lastCalculatedAt: 'lastCalculatedAt',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type UserAnalyticsScalarFieldEnum = (typeof UserAnalyticsScalarFieldEnum)[keyof typeof UserAnalyticsScalarFieldEnum]\n\n\nexport const CodingProblemScalarFieldEnum = {\n  id: 'id',\n  title: 'title',\n  description: 'description',\n  difficulty: 'difficulty',\n  category: 'category',\n  companies: 'companies',\n  constraints: 'constraints',\n  examples: 'examples',\n  testCases: 'testCases',\n  solutionApproaches: 'solutionApproaches',\n  starterCode: 'starterCode',\n  timeLimit: 'timeLimit',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type CodingProblemScalarFieldEnum = (typeof CodingProblemScalarFieldEnum)[keyof typeof CodingProblemScalarFieldEnum]\n\n\nexport const CodingChallengeScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  problemId: 'problemId',\n  testId: 'testId',\n  title: 'title',\n  description: 'description',\n  difficulty: 'difficulty',\n  category: 'category',\n  company: 'company',\n  language: 'language',\n  visibleTests: 'visibleTests',\n  hiddenTests: 'hiddenTests',\n  timeLimit: 'timeLimit',\n  status: 'status',\n  startedAt: 'startedAt',\n  endedAt: 'endedAt',\n  starterCode: 'starterCode',\n  finalCode: 'finalCode',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type CodingChallengeScalarFieldEnum = (typeof CodingChallengeScalarFieldEnum)[keyof typeof CodingChallengeScalarFieldEnum]\n\n\nexport const ChallengeSubmissionScalarFieldEnum = {\n  id: 'id',\n  challengeId: 'challengeId',\n  code: 'code',\n  language: 'language',\n  submittedAt: 'submittedAt',\n  evaluation: 'evaluation',\n  testResults: 'testResults',\n  isValid: 'isValid',\n  errorMessage: 'errorMessage'\n} as const\n\nexport type ChallengeSubmissionScalarFieldEnum = (typeof ChallengeSubmissionScalarFieldEnum)[keyof typeof ChallengeSubmissionScalarFieldEnum]\n\n\nexport const ChallengeScoreScalarFieldEnum = {\n  id: 'id',\n  challengeId: 'challengeId',\n  correctness: 'correctness',\n  efficiency: 'efficiency',\n  codeQuality: 'codeQuality',\n  edgeCases: 'edgeCases',\n  overallScore: 'overallScore',\n  passStatus: 'passStatus',\n  feedback: 'feedback',\n  suggestedApproach: 'suggestedApproach',\n  complexityAnalysis: 'complexityAnalysis',\n  createdAt: 'createdAt'\n} as const\n\nexport type ChallengeScoreScalarFieldEnum = (typeof ChallengeScoreScalarFieldEnum)[keyof typeof ChallengeScoreScalarFieldEnum]\n\n\nexport const CodingTestScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  status: 'status',\n  startedAt: 'startedAt',\n  endedAt: 'endedAt',\n  timeLimit: 'timeLimit',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type CodingTestScalarFieldEnum = (typeof CodingTestScalarFieldEnum)[keyof typeof CodingTestScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n/**\n * Reference to a field of type 'Float'\n */\nexport type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n/**\n * Reference to a field of type 'Boolean'\n */\nexport type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://pris.ly/d/logging).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n  /**\n   * SQL commenter plugins that add metadata to SQL queries as comments.\n   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   adapter,\n   *   comments: [\n   *     traceContext(),\n   *     queryInsights(),\n   *   ],\n   * })\n   * ```\n   */\n  comments?: runtime.SqlCommenterPlugin[]\n}\nexport type GlobalOmitConfig = {\n  user?: Prisma.UserOmit\n  profile?: Prisma.ProfileOmit\n  resume?: Prisma.ResumeOmit\n  interview?: Prisma.InterviewOmit\n  message?: Prisma.MessageOmit\n  score?: Prisma.ScoreOmit\n  userAnalytics?: Prisma.UserAnalyticsOmit\n  codingProblem?: Prisma.CodingProblemOmit\n  codingChallenge?: Prisma.CodingChallengeOmit\n  challengeSubmission?: Prisma.ChallengeSubmissionOmit\n  challengeScore?: Prisma.ChallengeScoreOmit\n  codingTest?: Prisma.CodingTestOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;;;;;CAUC,GAED;;AAcO,MAAM,gCAAgC,0UAAqC;AAG3E,MAAM,kCAAkC,4UAAuC;AAG/E,MAAM,6BAA6B,uUAAkC;AAGrE,MAAM,kCAAkC,4UAAuC;AAG/E,MAAM,8BAA8B,wUAAmC;AAMvE,MAAM,MAAM,mTAAc;AAC1B,MAAM,QAAQ,kTAAa;AAC3B,MAAM,OAAO,iTAAY;AACzB,MAAM,MAAM,gTAAW;AACvB,MAAM,MAAM,gTAAW;AAQvB,MAAM,UAAU,oTAAe;AAS/B,MAAM,sBAAsB,uTAAkB,CAAC,mBAAmB;AAelE,MAAM,gBAA+B;IAC1C,QAAQ;IACR,QAAQ;AACV;AAeO,MAAM,YAAY;IACvB,QAAQ,sTAAiB,CAAC,MAAM;IAChC,UAAU,sTAAiB,CAAC,QAAQ;IACpC,SAAS,sTAAiB,CAAC,OAAO;AACpC;AAMO,MAAM,SAAS,mTAAc;AAO7B,MAAM,WAAW,qTAAgB;AAOjC,MAAM,UAAU,oTAAe;AAkQ/B,MAAM,YAAY;IACvB,MAAM;IACN,SAAS;IACT,QAAQ;IACR,WAAW;IACX,SAAS;IACT,OAAO;IACP,eAAe;IACf,eAAe;IACf,iBAAiB;IACjB,qBAAqB;IACrB,gBAAgB;IAChB,YAAY;AACd;AAw6BO,MAAM,4BAA4B,2TAAsB,CAAC;IAC9D,cAAc;AAChB;AAKO,MAAM,sBAAsB;IACjC,IAAI;IACJ,OAAO;IACP,UAAU;IACV,MAAM;IACN,QAAQ;IACR,WAAW;IACX,WAAW;AACb;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,QAAQ;IACR,KAAK;IACL,iBAAiB;IACjB,QAAQ;IACR,iBAAiB;IACjB,YAAY;IACZ,WAAW;IACX,WAAW;AACb;AAKO,MAAM,wBAAwB;IACnC,IAAI;IACJ,QAAQ;IACR,UAAU;IACV,SAAS;IACT,UAAU;IACV,UAAU;IACV,UAAU;IACV,cAAc;IACd,aAAa;IACb,UAAU;IACV,YAAY;IACZ,gBAAgB;IAChB,YAAY;IACZ,WAAW;AACb;AAKO,MAAM,2BAA2B;IACtC,IAAI;IACJ,QAAQ;IACR,OAAO;IACP,YAAY;IACZ,QAAQ;IACR,WAAW;IACX,SAAS;IACT,WAAW;IACX,gBAAgB;IAChB,kBAAkB;AACpB;AAKO,MAAM,yBAAyB;IACpC,IAAI;IACJ,aAAa;IACb,MAAM;IACN,SAAS;IACT,WAAW;AACb;AAKO,MAAM,uBAAuB;IAClC,IAAI;IACJ,aAAa;IACb,2BAA2B;IAC3B,iBAAiB;IACjB,gBAAgB;IAChB,aAAa;IACb,WAAW;IACX,eAAe;IACf,cAAc;IACd,YAAY;IACZ,UAAU;IACV,WAAW;IACX,WAAW;AACb;AAKO,MAAM,+BAA+B;IAC1C,IAAI;IACJ,QAAQ;IACR,iBAAiB;IACjB,qBAAqB;IACrB,iBAAiB;IACjB,UAAU;IACV,gBAAgB;IAChB,kBAAkB;IAClB,YAAY;IACZ,YAAY;IACZ,kBAAkB;IAClB,WAAW;IACX,WAAW;AACb;AAKO,MAAM,+BAA+B;IAC1C,IAAI;IACJ,OAAO;IACP,aAAa;IACb,YAAY;IACZ,UAAU;IACV,WAAW;IACX,aAAa;IACb,UAAU;IACV,WAAW;IACX,oBAAoB;IACpB,aAAa;IACb,WAAW;IACX,WAAW;IACX,WAAW;AACb;AAKO,MAAM,iCAAiC;IAC5C,IAAI;IACJ,QAAQ;IACR,WAAW;IACX,QAAQ;IACR,OAAO;IACP,aAAa;IACb,YAAY;IACZ,UAAU;IACV,SAAS;IACT,UAAU;IACV,cAAc;IACd,aAAa;IACb,WAAW;IACX,QAAQ;IACR,WAAW;IACX,SAAS;IACT,aAAa;IACb,WAAW;IACX,WAAW;IACX,WAAW;AACb;AAKO,MAAM,qCAAqC;IAChD,IAAI;IACJ,aAAa;IACb,MAAM;IACN,UAAU;IACV,aAAa;IACb,YAAY;IACZ,aAAa;IACb,SAAS;IACT,cAAc;AAChB;AAKO,MAAM,gCAAgC;IAC3C,IAAI;IACJ,aAAa;IACb,aAAa;IACb,YAAY;IACZ,aAAa;IACb,WAAW;IACX,cAAc;IACd,YAAY;IACZ,UAAU;IACV,mBAAmB;IACnB,oBAAoB;IACpB,WAAW;AACb;AAKO,MAAM,4BAA4B;IACvC,IAAI;IACJ,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;AACb;AAKO,MAAM,YAAY;IACvB,KAAK;IACL,MAAM;AACR;AAKO,MAAM,aAAa;IACxB,OAAO;IACP,MAAM;AACR;AAoDO,MAAM,kBAAkB,uTAAkB,CAAC,eAAe"}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/enums.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n* This file exports all enum related types from the schema.\n*\n* ðŸŸ¢ You can import this file directly.\n*/\n\n\n\n// This file is empty because there are no enums in the schema.\nexport {}\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;AAIA,GAIA,+DAA+D"}},
    {"offset": {"line": 426, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/client.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.\n * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.\n *\n * ðŸŸ¢ You can import this file directly.\n */\n\nimport * as process from 'node:process'\nimport * as path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nglobalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport * as $Enums from \"./enums\"\nimport * as $Class from \"./internal/class\"\nimport * as Prisma from \"./internal/prismaNamespace\"\n\nexport * as $Enums from './enums'\nexport * from \"./enums\"\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.user.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\nexport const PrismaClient = $Class.getPrismaClientClass()\nexport type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions[\"omit\"] = Prisma.PrismaClientOptions[\"omit\"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>\nexport { Prisma }\n\n/**\n * Model User\n * \n */\nexport type User = Prisma.UserModel\n/**\n * Model Profile\n * \n */\nexport type Profile = Prisma.ProfileModel\n/**\n * Model Resume\n * \n */\nexport type Resume = Prisma.ResumeModel\n/**\n * Model Interview\n * \n */\nexport type Interview = Prisma.InterviewModel\n/**\n * Model Message\n * \n */\nexport type Message = Prisma.MessageModel\n/**\n * Model Score\n * \n */\nexport type Score = Prisma.ScoreModel\n/**\n * Model UserAnalytics\n * \n */\nexport type UserAnalytics = Prisma.UserAnalyticsModel\n/**\n * Model CodingProblem\n * \n */\nexport type CodingProblem = Prisma.CodingProblemModel\n/**\n * Model CodingChallenge\n * \n */\nexport type CodingChallenge = Prisma.CodingChallengeModel\n/**\n * Model ChallengeSubmission\n * \n */\nexport type ChallengeSubmission = Prisma.ChallengeSubmissionModel\n/**\n * Model ChallengeScore\n * \n */\nexport type ChallengeScore = Prisma.ChallengeScoreModel\n/**\n * Model CodingTest\n * \n */\nexport type CodingTest = Prisma.CodingTestModel\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;CAKC;;;;AAGD;AACA;AAKA;AACA;AAEA;;;;;;;;AAPA,UAAU,CAAC,YAAY,GAAG,4HAAY,CAAC,IAAA,gIAAa,EAAC,8BAAY,GAAG;;;;;AAsB7D,MAAM,eAAe,kPAA2B"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"../generated/prisma/client\";\nimport { PrismaLibSql } from \"@prisma/adapter-libsql\";\n\nconst adapter = new PrismaLibSql({\n  url: process.env.DATABASE_URL || \"file:./dev.db\",\n});\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({ adapter });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;;;;AAEA,MAAM,UAAU,IAAI,kQAAY,CAAC;IAC/B,KAAK,QAAQ,GAAG,CAAC,YAAY,IAAI;AACnC;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,+OAAY,CAAC;IAAE;AAAQ;AAE3E,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 492, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport bcrypt from \"bcryptjs\";\nimport { prisma } from \"./prisma\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  providers: [\n    Credentials({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const email = credentials.email as string;\n        const password = credentials.password as string;\n\n        const user = await prisma.user.findUnique({\n          where: { email },\n        });\n\n        if (!user) {\n          return null;\n        }\n\n        const isPasswordValid = await bcrypt.compare(password, user.password);\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.avatar,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.id = token.id as string;\n      }\n      return session;\n    },\n  },\n  pages: {\n    signIn: \"/login\",\n  },\n  session: {\n    strategy: \"jwt\",\n  },\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAEO,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,2OAAQ,EAAC;IAC1D,WAAW;QACT,IAAA,gPAAW,EAAC;YACV,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,QAAQ,YAAY,KAAK;gBAC/B,MAAM,WAAW,YAAY,QAAQ;gBAErC,MAAM,OAAO,MAAM,yMAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE;oBAAM;gBACjB;gBAEA,IAAI,CAAC,MAAM;oBACT,OAAO;gBACT;gBAEA,MAAM,kBAAkB,MAAM,uNAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;gBAEpE,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,MAAM;gBACpB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YAC5B;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;IACA,SAAS;QACP,UAAU;IACZ;AACF"}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/ollama-provider.ts"],"sourcesContent":["/**\n * Ollama Provider\n *\n * Handles all Ollama-specific LLM interactions with timeout support.\n */\n\nimport type { LLMMessage, LLMCompletionOptions, LLMResponse, LLMStreamResponse } from \"./index\";\n\nconst OLLAMA_BASE_URL = process.env.OLLAMA_BASE_URL || \"http://localhost:11434\";\nconst OLLAMA_MODEL = process.env.OLLAMA_MODEL || \"llama3\";\nconst OLLAMA_CODE_MODEL = process.env.OLLAMA_CODE_MODEL || \"codellama:7b\";\nconst OLLAMA_TIMEOUT = 30000; // 30 second timeout\n\nexport type OllamaModelType = \"general\" | \"coding\";\n\nfunction getModelForType(type: OllamaModelType): string {\n  return type === \"coding\" ? OLLAMA_CODE_MODEL : OLLAMA_MODEL;\n}\n\n/**\n * Check if Ollama is healthy\n */\nexport async function checkOllamaHealth(): Promise<boolean> {\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 5000);\n\n    const response = await fetch(`${OLLAMA_BASE_URL}/api/tags`, {\n      method: \"GET\",\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeout);\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Non-streaming completion with Ollama\n */\nexport async function ollamaComplete(\n  options: LLMCompletionOptions,\n  modelType: OllamaModelType = \"general\"\n): Promise<LLMResponse> {\n  const model = getModelForType(modelType);\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), OLLAMA_TIMEOUT);\n\n  try {\n    const response = await fetch(`${OLLAMA_BASE_URL}/api/chat`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model,\n        messages: options.messages,\n        stream: false,\n        options: {\n          temperature: options.temperature ?? 0.7,\n          num_predict: options.maxTokens ?? 800,\n          top_p: options.topP ?? 0.9,\n          stop: options.stop,\n        },\n      }),\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeout);\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Ollama error: ${error}`);\n    }\n\n    const data = await response.json();\n\n    return {\n      content: data.message?.content || \"\",\n      provider: \"ollama\",\n      fallbackUsed: false,\n      model,\n    };\n  } catch (error) {\n    clearTimeout(timeout);\n    throw error;\n  }\n}\n\n/**\n * Streaming completion with Ollama\n */\nexport async function ollamaStreamComplete(\n  options: LLMCompletionOptions,\n  modelType: OllamaModelType = \"general\"\n): Promise<LLMStreamResponse> {\n  const model = getModelForType(modelType);\n\n  const response = await fetch(`${OLLAMA_BASE_URL}/api/chat`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      model,\n      messages: options.messages,\n      stream: true,\n      options: {\n        temperature: options.temperature ?? 0.7,\n        num_predict: options.maxTokens ?? 800,\n        top_p: options.topP ?? 0.9,\n        stop: options.stop,\n      },\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`Ollama streaming error: ${error}`);\n  }\n\n  if (!response.body) {\n    throw new Error(\"No response body from Ollama\");\n  }\n\n  // Transform Ollama stream to SSE format\n  const stream = transformOllamaStream(response.body);\n\n  return {\n    stream,\n    provider: \"ollama\",\n    fallbackUsed: false,\n    model,\n  };\n}\n\n/**\n * Transform Ollama stream to SSE format\n */\nfunction transformOllamaStream(\n  ollamaStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n\n  return new ReadableStream({\n    async start(controller) {\n      const reader = ollamaStream.getReader();\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            controller.close();\n            break;\n          }\n\n          buffer += decoder.decode(value, { stream: true });\n\n          // Process complete JSON lines\n          const lines = buffer.split(\"\\n\");\n          buffer = lines.pop() || \"\";\n\n          for (const line of lines) {\n            if (line.trim()) {\n              try {\n                const json = JSON.parse(line);\n                if (json.message?.content) {\n                  const sseData = `data: ${JSON.stringify({ content: json.message.content })}\\n\\n`;\n                  controller.enqueue(encoder.encode(sseData));\n                }\n                if (json.done) {\n                  controller.enqueue(encoder.encode(\"data: [DONE]\\n\\n\"));\n                }\n              } catch {\n                // Skip invalid JSON lines\n              }\n            }\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 741, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/openai-provider.ts"],"sourcesContent":["/**\n * OpenAI Provider\n *\n * Handles all OpenAI-specific LLM interactions as fallback.\n */\n\nimport OpenAI from \"openai\";\nimport type { LLMCompletionOptions, LLMResponse, LLMStreamResponse } from \"./index\";\n\nconst OPENAI_MODEL = process.env.OPENAI_MODEL || \"gpt-4o-mini\";\n\nlet openaiClient: OpenAI | null = null;\n\nfunction getOpenAIClient(): OpenAI {\n  if (!openaiClient) {\n    if (!process.env.OPENAI_API_KEY) {\n      throw new Error(\"OpenAI API key not configured\");\n    }\n    openaiClient = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n    });\n  }\n  return openaiClient;\n}\n\n/**\n * Check if OpenAI is configured\n */\nexport function isOpenAIConfigured(): boolean {\n  return !!process.env.OPENAI_API_KEY;\n}\n\n/**\n * Non-streaming completion with OpenAI\n */\nexport async function openaiComplete(\n  options: LLMCompletionOptions\n): Promise<LLMResponse> {\n  const client = getOpenAIClient();\n\n  const response = await client.chat.completions.create({\n    model: OPENAI_MODEL,\n    messages: options.messages.map((m) => ({\n      role: m.role,\n      content: m.content,\n    })),\n    temperature: options.temperature ?? 0.7,\n    max_tokens: options.maxTokens ?? 800,\n    top_p: options.topP ?? 0.9,\n    stop: options.stop,\n  });\n\n  return {\n    content: response.choices[0]?.message?.content || \"\",\n    provider: \"openai\",\n    fallbackUsed: true,\n    model: OPENAI_MODEL,\n  };\n}\n\n/**\n * Streaming completion with OpenAI\n */\nexport async function openaiStreamComplete(\n  options: LLMCompletionOptions\n): Promise<LLMStreamResponse> {\n  const client = getOpenAIClient();\n\n  const response = await client.chat.completions.create({\n    model: OPENAI_MODEL,\n    messages: options.messages.map((m) => ({\n      role: m.role,\n      content: m.content,\n    })),\n    temperature: options.temperature ?? 0.7,\n    max_tokens: options.maxTokens ?? 800,\n    top_p: options.topP ?? 0.9,\n    stop: options.stop,\n    stream: true,\n  });\n\n  // Transform OpenAI stream to our SSE format\n  const stream = transformOpenAIStream(response);\n\n  return {\n    stream,\n    provider: \"openai\",\n    fallbackUsed: true,\n    model: OPENAI_MODEL,\n  };\n}\n\n/**\n * Transform OpenAI stream to SSE format matching our expected format\n */\nfunction transformOpenAIStream(\n  openaiStream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>\n): ReadableStream<Uint8Array> {\n  const encoder = new TextEncoder();\n\n  return new ReadableStream({\n    async start(controller) {\n      try {\n        for await (const chunk of openaiStream) {\n          const content = chunk.choices[0]?.delta?.content;\n          if (content) {\n            const sseData = `data: ${JSON.stringify({ content })}\\n\\n`;\n            controller.enqueue(encoder.encode(sseData));\n          }\n\n          // Check if this is the final chunk\n          if (chunk.choices[0]?.finish_reason) {\n            controller.enqueue(encoder.encode(\"data: [DONE]\\n\\n\"));\n          }\n        }\n        controller.close();\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;CAIC,GAED;AAAA;;AAGA,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI;AAEjD,IAAI,eAA8B;AAElC,SAAS;IACP,IAAI,CAAC,cAAc;QACjB,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;YAC/B,MAAM,IAAI,MAAM;QAClB;QACA,eAAe,IAAI,4PAAM,CAAC;YACxB,QAAQ,QAAQ,GAAG,CAAC,cAAc;QACpC;IACF;IACA,OAAO;AACT;AAKO,SAAS;IACd,OAAO,CAAC,CAAC,QAAQ,GAAG,CAAC,cAAc;AACrC;AAKO,eAAe,eACpB,OAA6B;IAE7B,MAAM,SAAS;IAEf,MAAM,WAAW,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;QACpD,OAAO;QACP,UAAU,QAAQ,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;gBACrC,MAAM,EAAE,IAAI;gBACZ,SAAS,EAAE,OAAO;YACpB,CAAC;QACD,aAAa,QAAQ,WAAW,IAAI;QACpC,YAAY,QAAQ,SAAS,IAAI;QACjC,OAAO,QAAQ,IAAI,IAAI;QACvB,MAAM,QAAQ,IAAI;IACpB;IAEA,OAAO;QACL,SAAS,SAAS,OAAO,CAAC,EAAE,EAAE,SAAS,WAAW;QAClD,UAAU;QACV,cAAc;QACd,OAAO;IACT;AACF;AAKO,eAAe,qBACpB,OAA6B;IAE7B,MAAM,SAAS;IAEf,MAAM,WAAW,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;QACpD,OAAO;QACP,UAAU,QAAQ,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;gBACrC,MAAM,EAAE,IAAI;gBACZ,SAAS,EAAE,OAAO;YACpB,CAAC;QACD,aAAa,QAAQ,WAAW,IAAI;QACpC,YAAY,QAAQ,SAAS,IAAI;QACjC,OAAO,QAAQ,IAAI,IAAI;QACvB,MAAM,QAAQ,IAAI;QAClB,QAAQ;IACV;IAEA,4CAA4C;IAC5C,MAAM,SAAS,sBAAsB;IAErC,OAAO;QACL;QACA,UAAU;QACV,cAAc;QACd,OAAO;IACT;AACF;AAEA;;CAEC,GACD,SAAS,sBACP,YAAwE;IAExE,MAAM,UAAU,IAAI;IAEpB,OAAO,IAAI,eAAe;QACxB,MAAM,OAAM,UAAU;YACpB,IAAI;gBACF,WAAW,MAAM,SAAS,aAAc;oBACtC,MAAM,UAAU,MAAM,OAAO,CAAC,EAAE,EAAE,OAAO;oBACzC,IAAI,SAAS;wBACX,MAAM,UAAU,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC;4BAAE;wBAAQ,GAAG,IAAI,CAAC;wBAC1D,WAAW,OAAO,CAAC,QAAQ,MAAM,CAAC;oBACpC;oBAEA,mCAAmC;oBACnC,IAAI,MAAM,OAAO,CAAC,EAAE,EAAE,eAAe;wBACnC,WAAW,OAAO,CAAC,QAAQ,MAAM,CAAC;oBACpC;gBACF;gBACA,WAAW,KAAK;YAClB,EAAE,OAAO,OAAO;gBACd,WAAW,KAAK,CAAC;YACnB;QACF;IACF;AACF"}},
    {"offset": {"line": 852, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/redis.ts"],"sourcesContent":["/**\n * Redis Client using Upstash\n *\n * Provides a singleton Redis client for caching.\n * Falls back gracefully if Redis is not configured.\n */\n\nimport { Redis } from \"@upstash/redis\";\n\n// Cache key prefixes for organization\nexport const CACHE_KEYS = {\n  USER_ANALYTICS: \"analytics:user:\",\n  LEADERBOARD: \"leaderboard:\",\n  OLLAMA_HEALTH: \"ollama:health\",\n  INTERVIEW_QUESTIONS: \"questions:\",\n} as const;\n\n// TTL values in seconds\nexport const CACHE_TTL = {\n  USER_ANALYTICS: 5 * 60,      // 5 minutes\n  LEADERBOARD: 60,             // 1 minute\n  OLLAMA_HEALTH: 30,           // 30 seconds\n  INTERVIEW_QUESTIONS: 60 * 60, // 1 hour\n} as const;\n\n// Check if Redis is configured\nconst isRedisConfigured = () => {\n  return !!(\n    process.env.UPSTASH_REDIS_REST_URL &&\n    process.env.UPSTASH_REDIS_REST_TOKEN\n  );\n};\n\n// Create Redis client singleton\nlet redisClient: Redis | null = null;\n\nexport function getRedisClient(): Redis | null {\n  if (!isRedisConfigured()) {\n    return null;\n  }\n\n  if (!redisClient) {\n    redisClient = new Redis({\n      url: process.env.UPSTASH_REDIS_REST_URL!,\n      token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n    });\n  }\n\n  return redisClient;\n}\n\n// Helper to check if Redis is available\nexport function isRedisAvailable(): boolean {\n  return isRedisConfigured();\n}\n\nexport { Redis };\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;CAKC,GAED;;AAGO,MAAM,aAAa;IACxB,gBAAgB;IAChB,aAAa;IACb,eAAe;IACf,qBAAqB;AACvB;AAGO,MAAM,YAAY;IACvB,gBAAgB,IAAI;IACpB,aAAa;IACb,eAAe;IACf,qBAAqB,KAAK;AAC5B;AAEA,+BAA+B;AAC/B,MAAM,oBAAoB;IACxB,OAAO,CAAC,CAAC,CACP,QAAQ,GAAG,CAAC,sBAAsB,IAClC,QAAQ,GAAG,CAAC,wBAAwB,AACtC;AACF;AAEA,gCAAgC;AAChC,IAAI,cAA4B;AAEzB,SAAS;IACd,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,aAAa;QAChB,cAAc,IAAI,iPAAK,CAAC;YACtB,KAAK,QAAQ,GAAG,CAAC,sBAAsB;YACvC,OAAO,QAAQ,GAAG,CAAC,wBAAwB;QAC7C;IACF;IAEA,OAAO;AACT;AAGO,SAAS;IACd,OAAO;AACT"}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/cache.ts"],"sourcesContent":["/**\n * Cache Utilities\n *\n * Provides helpers for caching with Redis.\n * All operations gracefully fall back to direct execution if Redis is unavailable.\n */\n\nimport { getRedisClient, isRedisAvailable, CACHE_TTL } from \"./redis\";\n\n/**\n * Get a cached value by key\n */\nexport async function cacheGet<T>(key: string): Promise<T | null> {\n  if (!isRedisAvailable()) {\n    return null;\n  }\n\n  try {\n    const redis = getRedisClient();\n    if (!redis) return null;\n\n    const value = await redis.get(key);\n    return value as T | null;\n  } catch (error) {\n    console.error(\"Cache get error:\", error);\n    return null;\n  }\n}\n\n/**\n * Set a cached value with TTL\n */\nexport async function cacheSet<T>(\n  key: string,\n  value: T,\n  ttlSeconds: number = CACHE_TTL.USER_ANALYTICS\n): Promise<boolean> {\n  if (!isRedisAvailable()) {\n    return false;\n  }\n\n  try {\n    const redis = getRedisClient();\n    if (!redis) return false;\n\n    await redis.set(key, JSON.stringify(value), { ex: ttlSeconds });\n    return true;\n  } catch (error) {\n    console.error(\"Cache set error:\", error);\n    return false;\n  }\n}\n\n/**\n * Delete a cached value\n */\nexport async function cacheDelete(key: string): Promise<boolean> {\n  if (!isRedisAvailable()) {\n    return false;\n  }\n\n  try {\n    const redis = getRedisClient();\n    if (!redis) return false;\n\n    await redis.del(key);\n    return true;\n  } catch (error) {\n    console.error(\"Cache delete error:\", error);\n    return false;\n  }\n}\n\n/**\n * Delete multiple cached values by pattern\n */\nexport async function cacheDeletePattern(pattern: string): Promise<boolean> {\n  if (!isRedisAvailable()) {\n    return false;\n  }\n\n  try {\n    const redis = getRedisClient();\n    if (!redis) return false;\n\n    // Upstash Redis supports SCAN for pattern matching\n    let cursor = 0;\n    do {\n      const [newCursor, keys] = await redis.scan(cursor, {\n        match: pattern,\n        count: 100,\n      });\n      cursor = parseInt(newCursor as string, 10);\n\n      if (keys.length > 0) {\n        await redis.del(...keys);\n      }\n    } while (cursor !== 0);\n\n    return true;\n  } catch (error) {\n    console.error(\"Cache delete pattern error:\", error);\n    return false;\n  }\n}\n\n/**\n * Get or fetch pattern - returns cached value or fetches and caches it\n */\nexport async function getOrFetch<T>(\n  key: string,\n  fetcher: () => Promise<T>,\n  ttlSeconds: number = CACHE_TTL.USER_ANALYTICS\n): Promise<T> {\n  // Try to get from cache first\n  const cached = await cacheGet<T>(key);\n  if (cached !== null) {\n    // Parse if it's a string (JSON)\n    if (typeof cached === \"string\") {\n      try {\n        return JSON.parse(cached) as T;\n      } catch {\n        return cached as T;\n      }\n    }\n    return cached;\n  }\n\n  // Fetch fresh data\n  const fresh = await fetcher();\n\n  // Cache the result\n  await cacheSet(key, fresh, ttlSeconds);\n\n  return fresh;\n}\n\n/**\n * Invalidate user analytics cache\n */\nexport async function invalidateUserAnalytics(userId: string): Promise<void> {\n  await cacheDeletePattern(`analytics:user:${userId}*`);\n}\n\n/**\n * Invalidate leaderboard cache\n */\nexport async function invalidateLeaderboard(): Promise<void> {\n  await cacheDeletePattern(\"leaderboard:*\");\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;CAKC,GAED;;AAKO,eAAe,SAAY,GAAW;IAC3C,IAAI,CAAC,IAAA,kOAAgB,KAAI;QACvB,OAAO;IACT;IAEA,IAAI;QACF,MAAM,QAAQ,IAAA,gOAAc;QAC5B,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,QAAQ,MAAM,MAAM,GAAG,CAAC;QAC9B,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO;IACT;AACF;AAKO,eAAe,SACpB,GAAW,EACX,KAAQ,EACR,aAAqB,2NAAS,CAAC,cAAc;IAE7C,IAAI,CAAC,IAAA,kOAAgB,KAAI;QACvB,OAAO;IACT;IAEA,IAAI;QACF,MAAM,QAAQ,IAAA,gOAAc;QAC5B,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,MAAM,GAAG,CAAC,KAAK,KAAK,SAAS,CAAC,QAAQ;YAAE,IAAI;QAAW;QAC7D,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO;IACT;AACF;AAKO,eAAe,YAAY,GAAW;IAC3C,IAAI,CAAC,IAAA,kOAAgB,KAAI;QACvB,OAAO;IACT;IAEA,IAAI;QACF,MAAM,QAAQ,IAAA,gOAAc;QAC5B,IAAI,CAAC,OAAO,OAAO;QAEnB,MAAM,MAAM,GAAG,CAAC;QAChB,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO;IACT;AACF;AAKO,eAAe,mBAAmB,OAAe;IACtD,IAAI,CAAC,IAAA,kOAAgB,KAAI;QACvB,OAAO;IACT;IAEA,IAAI;QACF,MAAM,QAAQ,IAAA,gOAAc;QAC5B,IAAI,CAAC,OAAO,OAAO;QAEnB,mDAAmD;QACnD,IAAI,SAAS;QACb,GAAG;YACD,MAAM,CAAC,WAAW,KAAK,GAAG,MAAM,MAAM,IAAI,CAAC,QAAQ;gBACjD,OAAO;gBACP,OAAO;YACT;YACA,SAAS,SAAS,WAAqB;YAEvC,IAAI,KAAK,MAAM,GAAG,GAAG;gBACnB,MAAM,MAAM,GAAG,IAAI;YACrB;QACF,QAAS,WAAW,EAAG;QAEvB,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;IACT;AACF;AAKO,eAAe,WACpB,GAAW,EACX,OAAyB,EACzB,aAAqB,2NAAS,CAAC,cAAc;IAE7C,8BAA8B;IAC9B,MAAM,SAAS,MAAM,SAAY;IACjC,IAAI,WAAW,MAAM;QACnB,gCAAgC;QAChC,IAAI,OAAO,WAAW,UAAU;YAC9B,IAAI;gBACF,OAAO,KAAK,KAAK,CAAC;YACpB,EAAE,OAAM;gBACN,OAAO;YACT;QACF;QACA,OAAO;IACT;IAEA,mBAAmB;IACnB,MAAM,QAAQ,MAAM;IAEpB,mBAAmB;IACnB,MAAM,SAAS,KAAK,OAAO;IAE3B,OAAO;AACT;AAKO,eAAe,wBAAwB,MAAc;IAC1D,MAAM,mBAAmB,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;AACtD;AAKO,eAAe;IACpB,MAAM,mBAAmB;AAC3B"}},
    {"offset": {"line": 1029, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/client.ts"],"sourcesContent":["/**\n * Unified LLM Client\n *\n * Provides a unified interface for LLM operations with automatic\n * fallback from Ollama to OpenAI when Ollama is unavailable.\n */\n\nimport type {\n  LLMCompletionOptions,\n  LLMResponse,\n  LLMStreamResponse,\n  ModelType,\n} from \"./index\";\nimport {\n  checkOllamaHealth,\n  ollamaComplete,\n  ollamaStreamComplete,\n  type OllamaModelType,\n} from \"./ollama-provider\";\nimport {\n  isOpenAIConfigured,\n  openaiComplete,\n  openaiStreamComplete,\n} from \"./openai-provider\";\nimport { getOrFetch } from \"@/lib/cache\";\nimport { CACHE_KEYS, CACHE_TTL } from \"@/lib/redis\";\n\n/**\n * Check LLM health with caching\n */\nexport async function checkLLMHealth(): Promise<{\n  ollamaAvailable: boolean;\n  openaiConfigured: boolean;\n}> {\n  const ollamaAvailable = await getOrFetch(\n    CACHE_KEYS.OLLAMA_HEALTH,\n    checkOllamaHealth,\n    CACHE_TTL.OLLAMA_HEALTH\n  );\n\n  return {\n    ollamaAvailable,\n    openaiConfigured: isOpenAIConfigured(),\n  };\n}\n\n/**\n * Non-streaming completion with automatic fallback\n */\nexport async function complete(\n  options: LLMCompletionOptions,\n  modelType: ModelType = \"general\"\n): Promise<LLMResponse> {\n  // Check Ollama health (cached)\n  const health = await checkLLMHealth();\n\n  // Try Ollama first if available\n  if (health.ollamaAvailable) {\n    try {\n      console.log(\"[LLM] Attempting Ollama completion...\");\n      const response = await ollamaComplete(\n        options,\n        modelType as OllamaModelType\n      );\n      console.log(\"[LLM] Ollama completion successful\");\n      return response;\n    } catch (error) {\n      console.warn(\"[LLM] Ollama failed, checking fallback:\", error);\n    }\n  }\n\n  // Fallback to OpenAI\n  if (health.openaiConfigured) {\n    console.log(\"[LLM] Falling back to OpenAI...\");\n    const response = await openaiComplete(options);\n    console.log(\"[LLM] OpenAI completion successful\");\n    return response;\n  }\n\n  throw new Error(\n    \"No LLM provider available. Ollama is not running and OpenAI is not configured.\"\n  );\n}\n\n/**\n * Streaming completion with automatic fallback\n */\nexport async function streamComplete(\n  options: LLMCompletionOptions,\n  modelType: ModelType = \"general\"\n): Promise<LLMStreamResponse> {\n  // Check Ollama health (cached)\n  const health = await checkLLMHealth();\n\n  // Try Ollama first if available\n  if (health.ollamaAvailable) {\n    try {\n      console.log(\"[LLM] Attempting Ollama streaming...\");\n      const response = await ollamaStreamComplete(\n        options,\n        modelType as OllamaModelType\n      );\n      console.log(\"[LLM] Ollama streaming started\");\n      return response;\n    } catch (error) {\n      console.warn(\"[LLM] Ollama streaming failed, checking fallback:\", error);\n    }\n  }\n\n  // Fallback to OpenAI\n  if (health.openaiConfigured) {\n    console.log(\"[LLM] Falling back to OpenAI streaming...\");\n    const response = await openaiStreamComplete(options);\n    console.log(\"[LLM] OpenAI streaming started\");\n    return response;\n  }\n\n  throw new Error(\n    \"No LLM provider available. Ollama is not running and OpenAI is not configured.\"\n  );\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;AAQD;AAMA;AAKA;AACA;;;;;AAKO,eAAe;IAIpB,MAAM,kBAAkB,MAAM,IAAA,4MAAU,EACtC,4NAAU,CAAC,aAAa,EACxB,uOAAiB,EACjB,2NAAS,CAAC,aAAa;IAGzB,OAAO;QACL;QACA,kBAAkB,IAAA,wOAAkB;IACtC;AACF;AAKO,eAAe,SACpB,OAA6B,EAC7B,YAAuB,SAAS;IAEhC,+BAA+B;IAC/B,MAAM,SAAS,MAAM;IAErB,gCAAgC;IAChC,IAAI,OAAO,eAAe,EAAE;QAC1B,IAAI;YACF,QAAQ,GAAG,CAAC;YACZ,MAAM,WAAW,MAAM,IAAA,oOAAc,EACnC,SACA;YAEF,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,2CAA2C;QAC1D;IACF;IAEA,qBAAqB;IACrB,IAAI,OAAO,gBAAgB,EAAE;QAC3B,QAAQ,GAAG,CAAC;QACZ,MAAM,WAAW,MAAM,IAAA,oOAAc,EAAC;QACtC,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT;IAEA,MAAM,IAAI,MACR;AAEJ;AAKO,eAAe,eACpB,OAA6B,EAC7B,YAAuB,SAAS;IAEhC,+BAA+B;IAC/B,MAAM,SAAS,MAAM;IAErB,gCAAgC;IAChC,IAAI,OAAO,eAAe,EAAE;QAC1B,IAAI;YACF,QAAQ,GAAG,CAAC;YACZ,MAAM,WAAW,MAAM,IAAA,0OAAoB,EACzC,SACA;YAEF,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,qDAAqD;QACpE;IACF;IAEA,qBAAqB;IACrB,IAAI,OAAO,gBAAgB,EAAE;QAC3B,QAAQ,GAAG,CAAC;QACZ,MAAM,WAAW,MAAM,IAAA,0OAAoB,EAAC;QAC5C,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT;IAEA,MAAM,IAAI,MACR;AAEJ"}},
    {"offset": {"line": 1107, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/index.ts"],"sourcesContent":["/**\n * LLM Types and Interfaces\n *\n * Unified type definitions for LLM interactions.\n */\n\nexport interface LLMMessage {\n  role: \"system\" | \"user\" | \"assistant\";\n  content: string;\n}\n\nexport interface LLMCompletionOptions {\n  messages: LLMMessage[];\n  temperature?: number;\n  maxTokens?: number;\n  topP?: number;\n  stop?: string[];\n  stream?: boolean;\n}\n\nexport interface LLMResponse {\n  content: string;\n  provider: \"ollama\" | \"openai\";\n  fallbackUsed: boolean;\n  model: string;\n}\n\nexport interface LLMStreamResponse {\n  stream: ReadableStream<Uint8Array>;\n  provider: \"ollama\" | \"openai\";\n  fallbackUsed: boolean;\n  model: string;\n}\n\nexport type ModelType = \"general\" | \"coding\";\n\n// Re-export client functions\nexport { complete, streamComplete, checkLLMHealth } from \"./client\";\n"],"names":[],"mappings":"AAAA;;;;CAIC;AAgCD,6BAA6B;AAC7B"}},
    {"offset": {"line": 1121, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/app/api/interview/%5Bid%5D/chat/route.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport { streamComplete, type LLMMessage } from \"@/lib/llm\";\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const session = await auth();\n\n    if (!session?.user?.id) {\n      return new Response(\"Unauthorized\", { status: 401 });\n    }\n\n    const { id } = await params;\n    const body = await request.json();\n    const { message, phaseContext, currentPhase } = body;\n\n    if (!message && !phaseContext) {\n      return new Response(\"Message or phaseContext is required\", { status: 400 });\n    }\n\n    // Verify ownership and get interview with messages\n    const interview = await prisma.interview.findFirst({\n      where: {\n        id,\n        userId: session.user.id,\n      },\n      include: {\n        messages: {\n          orderBy: { timestamp: \"asc\" },\n        },\n      },\n    });\n\n    if (!interview) {\n      return new Response(\"Interview not found\", { status: 404 });\n    }\n\n    if (interview.status === \"completed\") {\n      return new Response(\"Interview is already completed\", { status: 400 });\n    }\n\n    // Handle phase transition recording for time tracking\n    if (phaseContext) {\n      const currentTransitions: Array<{ phase: string; startedAt: string; endedAt?: string }> =\n        interview.phaseTransitions ? JSON.parse(interview.phaseTransitions) : [];\n\n      // Close previous phase if exists\n      if (currentTransitions.length > 0) {\n        const lastIndex = currentTransitions.length - 1;\n        if (!currentTransitions[lastIndex].endedAt) {\n          currentTransitions[lastIndex].endedAt = new Date().toISOString();\n        }\n      }\n\n      // Start new phase\n      currentTransitions.push({\n        phase: phaseContext,\n        startedAt: new Date().toISOString(),\n      });\n\n      await prisma.interview.update({\n        where: { id },\n        data: { phaseTransitions: JSON.stringify(currentTransitions) },\n      });\n    }\n\n    // Save user message only if provided\n    if (message) {\n      await prisma.message.create({\n        data: {\n          interviewId: id,\n          role: \"user\",\n          content: message,\n        },\n      });\n    }\n\n    // Build conversation history for LLM\n    const messages: LLMMessage[] = interview.messages.map((m) => ({\n      role: m.role as \"system\" | \"user\" | \"assistant\",\n      content: m.content,\n    }));\n\n    // Phase boundary enforcement reminder\n    const phaseReminders: Record<string, string> = {\n      requirements: \"You are currently in the REQUIREMENTS CLARIFICATION phase (45:00-37:00). ONLY ask about: scale (DAU, QPS, data size), functional requirements, non-functional requirements (latency, consistency), and priorities. DO NOT ask about architecture, components, databases, or implementation yet.\",\n      \"high-level\": \"You are currently in the HIGH-LEVEL DESIGN phase (37:00-25:00). ONLY ask about: overall architecture, main components, API design, data flow, and database choices at a high level. DO NOT dive into implementation details, algorithms, or schemas yet.\",\n      \"deep-dive\": \"You are currently in the DEEP DIVE phase (25:00-13:00). NOW you can ask about: data models, schemas, algorithms, protocols, implementation details, and failure scenarios. DO NOT ask about scalability strategies yet.\",\n      scalability: \"You are currently in the SCALABILITY phase (13:00-3:00). NOW you can ask about: scaling strategies (10x-100x), caching, sharding, load balancing, performance optimization, and trade-offs.\",\n      wrapup: \"You are currently in the WRAP-UP phase (3:00-0:00). Summarize the design, address remaining concerns, and answer candidate questions.\",\n    };\n\n    // Add context or user message\n    if (phaseContext) {\n      messages.push({\n        role: \"system\",\n        content: `TRANSITION: The interview timer has advanced to the \"${phaseContext}\" phase. \n        Please acknowledge this transition, briefly wrap up the previous topic if needed, and immediately start the ${phaseContext} phase by asking a relevant question. \n        Do not wait for the user to respond to the previous topic. Focus on the new phase requirements.`,\n      });\n    } else if (currentPhase && phaseReminders[currentPhase]) {\n      // Add phase reminder for regular messages\n      messages.push({\n        role: \"system\",\n        content: phaseReminders[currentPhase],\n      });\n    }\n\n    if (message) {\n      messages.push({ role: \"user\", content: message });\n    }\n\n    // Create streaming response using LLM (Ollama with OpenAI fallback)\n    const llmResponse = await streamComplete({\n      messages,\n      temperature: 0.7,\n      maxTokens: 800,\n    });\n\n    // Create a ReadableStream for the response\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    let fullResponse = \"\";\n    let buffer = \"\";\n\n    const readable = new ReadableStream({\n      async start(controller) {\n        const reader = llmResponse.stream.getReader();\n\n        try {\n          while (true) {\n            const { done, value } = await reader.read();\n\n            if (done) {\n              // Save the complete assistant message only if it's NOT a phase transition\n              // Phase transitions are handled by frontend state and shouldn't be duplicated in DB\n              if (fullResponse.trim() && !phaseContext) {\n                await prisma.message.create({\n                  data: {\n                    interviewId: id,\n                    role: \"assistant\",\n                    content: fullResponse,\n                  },\n                });\n              }\n\n              controller.enqueue(encoder.encode(`data: ${JSON.stringify({ done: true })}\\n\\n`));\n              controller.close();\n              break;\n            }\n\n            // Decode the chunk and add to buffer\n            buffer += decoder.decode(value, { stream: true });\n\n            // Process SSE data format from our LLM abstraction\n            const lines = buffer.split(\"\\n\");\n            buffer = lines.pop() || \"\";\n\n            for (const line of lines) {\n              if (line.startsWith(\"data: \")) {\n                const data = line.slice(6);\n                if (data === \"[DONE]\") {\n                  continue;\n                }\n                try {\n                  const json = JSON.parse(data);\n                  if (json.content) {\n                    fullResponse += json.content;\n                    controller.enqueue(encoder.encode(`data: ${JSON.stringify({ content: json.content })}\\n\\n`));\n                  }\n                } catch {\n                  // Skip invalid JSON lines\n                }\n              }\n            }\n          }\n        } catch (error) {\n          console.error(\"Stream error:\", error);\n\n          // Save partial response if any (but not for phase transitions)\n          if (fullResponse.trim() && !phaseContext) {\n            await prisma.message.create({\n              data: {\n                interviewId: id,\n                role: \"assistant\",\n                content: fullResponse,\n              },\n            });\n          }\n\n          controller.error(error);\n        }\n      },\n    });\n\n    return new Response(readable, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n      },\n    });\n  } catch (error) {\n    console.error(\"Chat error:\", error);\n    return new Response(\"Internal server error\", { status: 500 });\n  }\n}\n"],"names":[],"mappings":"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"}}]
}