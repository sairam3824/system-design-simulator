{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/internal/class.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * Please import the `PrismaClient` class from the `client.ts` file instead.\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"./prismaNamespace\"\n\n\nconst config: runtime.GetPrismaClientConfig = {\n  \"previewFeatures\": [],\n  \"clientVersion\": \"7.3.0\",\n  \"engineVersion\": \"9d6ad21cbbceab97458517b147a6a09ff43aa735\",\n  \"activeProvider\": \"sqlite\",\n  \"inlineSchema\": \"// Prisma schema for AI System Design Simulator\\ngenerator client {\\n  provider = \\\"prisma-client\\\"\\n  output   = \\\"../src/generated/prisma\\\"\\n}\\n\\ndatasource db {\\n  provider = \\\"sqlite\\\"\\n}\\n\\nmodel User {\\n  id        String   @id @default(cuid())\\n  email     String   @unique\\n  password  String\\n  name      String?\\n  avatar    String?\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n\\n  profile          Profile?\\n  resumes          Resume[]\\n  interviews       Interview[]\\n  analytics        UserAnalytics?\\n  codingChallenges CodingChallenge[]\\n  codingTests      CodingTest[]\\n}\\n\\nmodel Profile {\\n  id     String @id @default(cuid())\\n  userId String @unique\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  bio             String?\\n  yearsExperience Int?\\n  skills          String  @default(\\\"[]\\\") // JSON array stored as string\\n  targetCompanies String  @default(\\\"[]\\\") // JSON array stored as string\\n  targetRole      String?\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n\\nmodel Resume {\\n  id     String @id @default(cuid())\\n  userId String\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  fileName String\\n  content  String // Full text content of resume\\n  analysis String? // JSON object with AI analysis\\n  filePath String? // Local path to the stored resume file\\n\\n  // ATS Score Data\\n  atsScore       Int? // Total ATS score (0-100)\\n  atsBreakdown   String? // JSON: { contactInfo, structure, experience, keywords, impact }\\n  atsFeedback    String? // JSON array of feedback strings\\n  keywords       String? // JSON array of extracted keywords\\n  softSkills     String? // JSON array of soft skills\\n  predictedRoles String? // JSON array of predicted job roles\\n\\n  uploadedAt DateTime @default(now())\\n  updatedAt  DateTime @updatedAt\\n}\\n\\nmodel Interview {\\n  id     String @id @default(cuid())\\n  userId String\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  topic      String // e.g., \\\"Design Twitter\\\", \\\"Design Uber\\\"\\n  difficulty String @default(\\\"medium\\\") // easy, medium, hard\\n  status     String @default(\\\"pending\\\") // pending, in_progress, completed\\n\\n  startedAt DateTime?\\n  endedAt   DateTime?\\n  createdAt DateTime  @default(now())\\n\\n  // Time tracking for phases\\n  phaseDurations   String? // JSON: { requirements: 480, highLevel: 720 } in seconds\\n  phaseTransitions String? // JSON: [{ phase: \\\"requirements\\\", startedAt: ISO, endedAt: ISO }]\\n\\n  messages Message[]\\n  score    Score?\\n\\n  @@index([userId, status, endedAt])\\n}\\n\\nmodel Message {\\n  id          String    @id @default(cuid())\\n  interviewId String\\n  interview   Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)\\n\\n  role    String // user, assistant, system\\n  content String\\n\\n  timestamp DateTime @default(now())\\n}\\n\\nmodel Score {\\n  id          String    @id @default(cuid())\\n  interviewId String    @unique\\n  interview   Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)\\n\\n  // 6 Industry-Standard FAANG Evaluation Dimensions (1-4 scale)\\n  requirementsClarification Int @default(0)\\n  highLevelDesign           Int @default(0)\\n  detailedDesign            Int @default(0)\\n  scalability               Int @default(0)\\n  tradeoffs                 Int @default(0)\\n  communication             Int @default(0)\\n\\n  // Calculated fields\\n  overallScore Float   @default(0) // Weighted average\\n  passStatus   Boolean @default(false)\\n\\n  // Detailed feedback as JSON\\n  feedback String @default(\\\"{}\\\") // JSON with per-dimension comments\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n\\n// Cached analytics for user performance tracking\\nmodel UserAnalytics {\\n  id     String @id @default(cuid())\\n  userId String @unique\\n  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)\\n\\n  // Cached aggregates (updated after each interview)\\n  totalInterviews     Int    @default(0)\\n  completedInterviews Int    @default(0)\\n  avgOverallScore     Float?\\n  passRate            Float?\\n\\n  // Weak/strong areas tracking\\n  weakDimensions   String @default(\\\"[]\\\") // JSON array: [\\\"scalability\\\", \\\"tradeoffs\\\"]\\n  strongDimensions String @default(\\\"[]\\\") // JSON array: [\\\"communication\\\", \\\"requirements\\\"]\\n\\n  // Topic performance\\n  topicStats String @default(\\\"{}\\\") // JSON: { \\\"Design Twitter\\\": { count: 5, avgScore: 2.8 } }\\n\\n  // Trend data\\n  scoreTrend       String   @default(\\\"stable\\\") // \\\"improving\\\" | \\\"stable\\\" | \\\"declining\\\"\\n  lastCalculatedAt DateTime @default(now())\\n\\n  createdAt DateTime @default(now())\\n  updatedAt DateTime @updatedAt\\n}\\n\\n// ==================== CODING CHALLENGE MODELS ====================\\n\\n// Predefined problem bank\\nmodel CodingProblem {\\n  id                 String            @id @default(cuid())\\n  title              String\\n  description        String\\n  difficulty         String // easy, medium, hard\\n  category           String // arrays, strings, dp, graphs, trees, etc.\\n  companies          String            @default(\\\"[]\\\") // JSON array of company names\\n  constraints        String            @default(\\\"[]\\\") // JSON array\\n  examples           String            @default(\\\"[]\\\") // JSON [{input, output, explanation}]\\n  testCases          String            @default(\\\"[]\\\") // JSON [{input, expectedOutput, isHidden}]\\n  solutionApproaches String            @default(\\\"[]\\\") // JSON array\\n  starterCode        String            @default(\\\"{}\\\") // JSON {python: \\\"...\\\", java: \\\"...\\\"}\\n  timeLimit          Int               @default(45) // minutes\\n  createdAt          DateTime          @default(now())\\n  updatedAt          DateTime          @updatedAt\\n  challenges         CodingChallenge[]\\n\\n  @@index([difficulty, category])\\n}\\n\\n// User's coding challenge instance\\nmodel CodingChallenge {\\n  id           String                @id @default(cuid())\\n  userId       String\\n  user         User                  @relation(fields: [userId], references: [id], onDelete: Cascade)\\n  problemId    String?\\n  problem      CodingProblem?        @relation(fields: [problemId], references: [id])\\n  testId       String?\\n  test         CodingTest?           @relation(fields: [testId], references: [id], onDelete: Cascade)\\n  title        String\\n  description  String\\n  difficulty   String\\n  category     String\\n  company      String?\\n  language     String // python, java, javascript, cpp, c, csharp, go\\n  visibleTests String                @default(\\\"[]\\\")\\n  hiddenTests  String                @default(\\\"[]\\\")\\n  timeLimit    Int                   @default(45)\\n  status       String                @default(\\\"pending\\\") // pending, in_progress, completed\\n  startedAt    DateTime?\\n  endedAt      DateTime?\\n  starterCode  String?\\n  finalCode    String?\\n  createdAt    DateTime              @default(now())\\n  updatedAt    DateTime              @updatedAt\\n  submissions  ChallengeSubmission[]\\n  score        ChallengeScore?\\n\\n  @@index([userId, status])\\n}\\n\\n// Code submission for evaluation\\nmodel ChallengeSubmission {\\n  id           String          @id @default(cuid())\\n  challengeId  String\\n  challenge    CodingChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)\\n  code         String\\n  language     String\\n  submittedAt  DateTime        @default(now())\\n  evaluation   String?\\n  testResults  String?\\n  isValid      Boolean         @default(false)\\n  errorMessage String?\\n\\n  @@index([challengeId])\\n}\\n\\n// Final score for coding challenge\\nmodel ChallengeScore {\\n  id                 String          @id @default(cuid())\\n  challengeId        String          @unique\\n  challenge          CodingChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)\\n  correctness        Float\\n  efficiency         Float\\n  codeQuality        Float\\n  edgeCases          Float\\n  overallScore       Float\\n  passStatus         Boolean\\n  feedback           String\\n  suggestedApproach  String?\\n  complexityAnalysis String?\\n  createdAt          DateTime        @default(now())\\n}\\n\\n// ==================== CODING TEST MODELS ====================\\n\\nmodel CodingTest {\\n  id         String            @id @default(cuid())\\n  userId     String\\n  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)\\n  challenges CodingChallenge[]\\n  status     String            @default(\\\"pending\\\") // pending, in_progress, completed\\n  startedAt  DateTime?\\n  endedAt    DateTime?\\n  timeLimit  Int // Total minutes for all questions\\n  createdAt  DateTime          @default(now())\\n  updatedAt  DateTime          @updatedAt\\n}\\n\",\n  \"runtimeDataModel\": {\n    \"models\": {},\n    \"enums\": {},\n    \"types\": {}\n  }\n}\n\nconfig.runtimeDataModel = JSON.parse(\"{\\\"models\\\":{\\\"User\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"email\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"password\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"name\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"avatar\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"profile\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Profile\\\",\\\"relationName\\\":\\\"ProfileToUser\\\"},{\\\"name\\\":\\\"resumes\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Resume\\\",\\\"relationName\\\":\\\"ResumeToUser\\\"},{\\\"name\\\":\\\"interviews\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Interview\\\",\\\"relationName\\\":\\\"InterviewToUser\\\"},{\\\"name\\\":\\\"analytics\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"UserAnalytics\\\",\\\"relationName\\\":\\\"UserToUserAnalytics\\\"},{\\\"name\\\":\\\"codingChallenges\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"CodingChallengeToUser\\\"},{\\\"name\\\":\\\"codingTests\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingTest\\\",\\\"relationName\\\":\\\"CodingTestToUser\\\"}],\\\"dbName\\\":null},\\\"Profile\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"ProfileToUser\\\"},{\\\"name\\\":\\\"bio\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"yearsExperience\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"skills\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"targetCompanies\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"targetRole\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"Resume\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"ResumeToUser\\\"},{\\\"name\\\":\\\"fileName\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"content\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"analysis\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"filePath\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"atsScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"atsBreakdown\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"atsFeedback\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"keywords\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"softSkills\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"predictedRoles\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"uploadedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"Interview\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"InterviewToUser\\\"},{\\\"name\\\":\\\"topic\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"difficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"endedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"phaseDurations\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"phaseTransitions\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"messages\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Message\\\",\\\"relationName\\\":\\\"InterviewToMessage\\\"},{\\\"name\\\":\\\"score\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Score\\\",\\\"relationName\\\":\\\"InterviewToScore\\\"}],\\\"dbName\\\":null},\\\"Message\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interviewId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interview\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Interview\\\",\\\"relationName\\\":\\\"InterviewToMessage\\\"},{\\\"name\\\":\\\"role\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"content\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"timestamp\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"Score\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interviewId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"interview\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"Interview\\\",\\\"relationName\\\":\\\"InterviewToScore\\\"},{\\\"name\\\":\\\"requirementsClarification\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"highLevelDesign\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"detailedDesign\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"scalability\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"tradeoffs\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"communication\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"overallScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"passStatus\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"feedback\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"UserAnalytics\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"UserToUserAnalytics\\\"},{\\\"name\\\":\\\"totalInterviews\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"completedInterviews\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"avgOverallScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"passRate\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"weakDimensions\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"strongDimensions\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"topicStats\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"scoreTrend\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"lastCalculatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"CodingProblem\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"description\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"difficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"companies\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"constraints\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"examples\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"testCases\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"solutionApproaches\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"starterCode\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"timeLimit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"challenges\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingProblem\\\"}],\\\"dbName\\\":null},\\\"CodingChallenge\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"CodingChallengeToUser\\\"},{\\\"name\\\":\\\"problemId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"problem\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingProblem\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingProblem\\\"},{\\\"name\\\":\\\"testId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"test\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingTest\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingTest\\\"},{\\\"name\\\":\\\"title\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"description\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"difficulty\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"category\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"company\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"language\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"visibleTests\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"hiddenTests\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"timeLimit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"endedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"starterCode\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"finalCode\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"submissions\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"ChallengeSubmission\\\",\\\"relationName\\\":\\\"ChallengeSubmissionToCodingChallenge\\\"},{\\\"name\\\":\\\"score\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"ChallengeScore\\\",\\\"relationName\\\":\\\"ChallengeScoreToCodingChallenge\\\"}],\\\"dbName\\\":null},\\\"ChallengeSubmission\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challengeId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challenge\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"ChallengeSubmissionToCodingChallenge\\\"},{\\\"name\\\":\\\"code\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"language\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"submittedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"evaluation\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"testResults\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"isValid\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"errorMessage\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"}],\\\"dbName\\\":null},\\\"ChallengeScore\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challengeId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"challenge\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"ChallengeScoreToCodingChallenge\\\"},{\\\"name\\\":\\\"correctness\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"efficiency\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"codeQuality\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"edgeCases\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"overallScore\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Float\\\"},{\\\"name\\\":\\\"passStatus\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Boolean\\\"},{\\\"name\\\":\\\"feedback\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"suggestedApproach\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"complexityAnalysis\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null},\\\"CodingTest\\\":{\\\"fields\\\":[{\\\"name\\\":\\\"id\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"userId\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"user\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"User\\\",\\\"relationName\\\":\\\"CodingTestToUser\\\"},{\\\"name\\\":\\\"challenges\\\",\\\"kind\\\":\\\"object\\\",\\\"type\\\":\\\"CodingChallenge\\\",\\\"relationName\\\":\\\"CodingChallengeToCodingTest\\\"},{\\\"name\\\":\\\"status\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"String\\\"},{\\\"name\\\":\\\"startedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"endedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"timeLimit\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"Int\\\"},{\\\"name\\\":\\\"createdAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"},{\\\"name\\\":\\\"updatedAt\\\",\\\"kind\\\":\\\"scalar\\\",\\\"type\\\":\\\"DateTime\\\"}],\\\"dbName\\\":null}},\\\"enums\\\":{},\\\"types\\\":{}}\")\n\nasync function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {\n  const { Buffer } = await import('node:buffer')\n  const wasmArray = Buffer.from(wasmBase64, 'base64')\n  return new WebAssembly.Module(wasmArray)\n}\n\nconfig.compilerWasm = {\n  getRuntime: async () => await import(\"@prisma/client/runtime/query_compiler_fast_bg.sqlite.mjs\"),\n\n  getQueryCompilerWasmModule: async () => {\n    const { wasm } = await import(\"@prisma/client/runtime/query_compiler_fast_bg.sqlite.wasm-base64.mjs\")\n    return await decodeBase64AsWasm(wasm)\n  },\n\n  importName: \"./query_compiler_fast_bg.js\"\n}\n\n\n\nexport type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =\n  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never\n\nexport interface PrismaClientConstructor {\n    /**\n   * ## Prisma Client\n   * \n   * Type-safe database client for TypeScript\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Users\n   * const users = await prisma.user.findMany()\n   * ```\n   * \n   * Read more in our [docs](https://pris.ly/d/client).\n   */\n\n  new <\n    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n    LogOpts extends LogOptions<Options> = LogOptions<Options>,\n    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],\n    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>\n}\n\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.user.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\n\nexport interface PrismaClient<\n  in LogOpts extends Prisma.LogLevel = never,\n  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,\n  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): runtime.Types.Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): runtime.Types.Utils.JsPromise<void>;\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://pris.ly/d/raw-queries).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>\n\n  $extends: runtime.Types.Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.user`: Exposes CRUD operations for the **User** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Users\n    * const users = await prisma.user.findMany()\n    * ```\n    */\n  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Profiles\n    * const profiles = await prisma.profile.findMany()\n    * ```\n    */\n  get profile(): Prisma.ProfileDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.resume`: Exposes CRUD operations for the **Resume** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Resumes\n    * const resumes = await prisma.resume.findMany()\n    * ```\n    */\n  get resume(): Prisma.ResumeDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.interview`: Exposes CRUD operations for the **Interview** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Interviews\n    * const interviews = await prisma.interview.findMany()\n    * ```\n    */\n  get interview(): Prisma.InterviewDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.message`: Exposes CRUD operations for the **Message** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Messages\n    * const messages = await prisma.message.findMany()\n    * ```\n    */\n  get message(): Prisma.MessageDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.score`: Exposes CRUD operations for the **Score** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Scores\n    * const scores = await prisma.score.findMany()\n    * ```\n    */\n  get score(): Prisma.ScoreDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.userAnalytics`: Exposes CRUD operations for the **UserAnalytics** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more UserAnalytics\n    * const userAnalytics = await prisma.userAnalytics.findMany()\n    * ```\n    */\n  get userAnalytics(): Prisma.UserAnalyticsDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.codingProblem`: Exposes CRUD operations for the **CodingProblem** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more CodingProblems\n    * const codingProblems = await prisma.codingProblem.findMany()\n    * ```\n    */\n  get codingProblem(): Prisma.CodingProblemDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.codingChallenge`: Exposes CRUD operations for the **CodingChallenge** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more CodingChallenges\n    * const codingChallenges = await prisma.codingChallenge.findMany()\n    * ```\n    */\n  get codingChallenge(): Prisma.CodingChallengeDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.challengeSubmission`: Exposes CRUD operations for the **ChallengeSubmission** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more ChallengeSubmissions\n    * const challengeSubmissions = await prisma.challengeSubmission.findMany()\n    * ```\n    */\n  get challengeSubmission(): Prisma.ChallengeSubmissionDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.challengeScore`: Exposes CRUD operations for the **ChallengeScore** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more ChallengeScores\n    * const challengeScores = await prisma.challengeScore.findMany()\n    * ```\n    */\n  get challengeScore(): Prisma.ChallengeScoreDelegate<ExtArgs, { omit: OmitOpts }>;\n\n  /**\n   * `prisma.codingTest`: Exposes CRUD operations for the **CodingTest** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more CodingTests\n    * const codingTests = await prisma.codingTest.findMany()\n    * ```\n    */\n  get codingTest(): Prisma.CodingTestDelegate<ExtArgs, { omit: OmitOpts }>;\n}\n\nexport function getPrismaClientClass(): PrismaClientConstructor {\n  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor\n}\n"],"names":[],"mappings":";;;;AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;;CAMC,GAED;;AAIA,MAAM,SAAwC;IAC5C,mBAAmB,EAAE;IACrB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,gBAAgB;IAChB,oBAAoB;QAClB,UAAU,CAAC;QACX,SAAS,CAAC;QACV,SAAS,CAAC;IACZ;AACF;AAEA,OAAO,gBAAgB,GAAG,KAAK,KAAK,CAAC;AAErC,eAAe,mBAAmB,UAAkB;IAClD,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,MAAM,YAAY,OAAO,IAAI,CAAC,YAAY;IAC1C,OAAO,IAAI,YAAY,MAAM,CAAC;AAChC;AAEA,OAAO,YAAY,GAAG;IACpB,YAAY,UAAY;IAExB,4BAA4B;QAC1B,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,OAAO,MAAM,mBAAmB;IAClC;IAEA,YAAY;AACd;AA4PO,SAAS;IACd,OAAO,4TAAuB,CAAC;AACjC"}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/internal/prismaNamespace.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * WARNING: This is an internal file that is subject to change!\n *\n * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘\n *\n * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.\n * While this enables partial backward compatibility, it is not part of the stable public API.\n *\n * If you are looking for your Models, Enums, and Input Types, please import them from the respective\n * model files in the `model` directory!\n */\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport type * as Prisma from \"../models\"\nimport { type PrismaClient } from \"./class\"\n\nexport type * from '../models'\n\nexport type DMMF = typeof runtime.DMMF\n\nexport type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>\n\n/**\n * Prisma Errors\n */\n\nexport const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\nexport type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n\nexport const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\nexport type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n\nexport const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\nexport type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n\nexport const PrismaClientInitializationError = runtime.PrismaClientInitializationError\nexport type PrismaClientInitializationError = runtime.PrismaClientInitializationError\n\nexport const PrismaClientValidationError = runtime.PrismaClientValidationError\nexport type PrismaClientValidationError = runtime.PrismaClientValidationError\n\n/**\n * Re-export of sql-template-tag\n */\nexport const sql = runtime.sqltag\nexport const empty = runtime.empty\nexport const join = runtime.join\nexport const raw = runtime.raw\nexport const Sql = runtime.Sql\nexport type Sql = runtime.Sql\n\n\n\n/**\n * Decimal.js\n */\nexport const Decimal = runtime.Decimal\nexport type Decimal = runtime.Decimal\n\nexport type DecimalJsLike = runtime.DecimalJsLike\n\n/**\n* Extensions\n*/\nexport type Extension = runtime.Types.Extensions.UserArgs\nexport const getExtensionContext = runtime.Extensions.getExtensionContext\nexport type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>\nexport type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>\nexport type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>\nexport type Exact<A, W> = runtime.Types.Public.Exact<A, W>\n\nexport type PrismaVersion = {\n  client: string\n  engine: string\n}\n\n/**\n * Prisma Client JS version: 7.3.0\n * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735\n */\nexport const prismaVersion: PrismaVersion = {\n  client: \"7.3.0\",\n  engine: \"9d6ad21cbbceab97458517b147a6a09ff43aa735\"\n}\n\n/**\n * Utility Types\n */\n\nexport type Bytes = runtime.Bytes\nexport type JsonObject = runtime.JsonObject\nexport type JsonArray = runtime.JsonArray\nexport type JsonValue = runtime.JsonValue\nexport type InputJsonObject = runtime.InputJsonObject\nexport type InputJsonArray = runtime.InputJsonArray\nexport type InputJsonValue = runtime.InputJsonValue\n\n\nexport const NullTypes = {\n  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),\n  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),\n  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),\n}\n/**\n * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const DbNull = runtime.DbNull\n\n/**\n * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const JsonNull = runtime.JsonNull\n\n/**\n * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n *\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n */\nexport const AnyNull = runtime.AnyNull\n\n\ntype SelectAndInclude = {\n  select: any\n  include: any\n}\n\ntype SelectAndOmit = {\n  select: any\n  omit: any\n}\n\n/**\n * From T, pick a set of properties whose keys are in the union K\n */\ntype Prisma__Pick<T, K extends keyof T> = {\n    [P in K]: T[P];\n};\n\nexport type Enumerable<T> = T | Array<T>;\n\n/**\n * Subset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n */\nexport type Subset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never;\n};\n\n/**\n * SelectSubset\n * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n * Additionally, it validates, if both select and include are present. If the case, it errors.\n */\nexport type SelectSubset<T, U> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  (T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`.'\n    : T extends SelectAndOmit\n      ? 'Please either choose `select` or `omit`.'\n      : {})\n\n/**\n * Subset + Intersection\n * @desc From `T` pick properties that exist in `U` and intersect `K`\n */\nexport type SubsetIntersection<T, U, K> = {\n  [key in keyof T]: key extends keyof U ? T[key] : never\n} &\n  K\n\ntype Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n/**\n * XOR is needed to have a real mutually exclusive union type\n * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n */\nexport type XOR<T, U> =\n  T extends object ?\n  U extends object ?\n    (Without<T, U> & U) | (Without<U, T> & T)\n  : U : T\n\n\n/**\n * Is T a Record?\n */\ntype IsObject<T extends any> = T extends Array<any>\n? False\n: T extends Date\n? False\n: T extends Uint8Array\n? False\n: T extends BigInt\n? False\n: T extends object\n? True\n: False\n\n\n/**\n * If it's T[], return T\n */\nexport type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n/**\n * From ts-toolbelt\n */\n\ntype __Either<O extends object, K extends Key> = Omit<O, K> &\n  {\n    // Merge all but K\n    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n  }[K]\n\ntype EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\ntype EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\ntype _Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean\n> = {\n  1: EitherStrict<O, K>\n  0: EitherLoose<O, K>\n}[strict]\n\nexport type Either<\n  O extends object,\n  K extends Key,\n  strict extends Boolean = 1\n> = O extends unknown ? _Either<O, K, strict> : never\n\nexport type Union = any\n\nexport type PatchUndefined<O extends object, O1 extends object> = {\n  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n} & {}\n\n/** Helper Types for \"Merge\" **/\nexport type IntersectOf<U extends Union> = (\n  U extends unknown ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never\n\nexport type Overwrite<O extends object, O1 extends object> = {\n    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n} & {};\n\ntype _Merge<U extends object> = IntersectOf<Overwrite<U, {\n    [K in keyof U]-?: At<U, K>;\n}>>;\n\ntype Key = string | number | symbol;\ntype AtStrict<O extends object, K extends Key> = O[K & keyof O];\ntype AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\nexport type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n    1: AtStrict<O, K>;\n    0: AtLoose<O, K>;\n}[strict];\n\nexport type ComputeRaw<A extends any> = A extends Function ? A : {\n  [K in keyof A]: A[K];\n} & {};\n\nexport type OptionalFlat<O> = {\n  [K in keyof O]?: O[K];\n} & {};\n\ntype _Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n\n// cause typescript not to expand types and preserve names\ntype NoExpand<T> = T extends unknown ? T : never;\n\n// this type assumes the passed object is entirely optional\nexport type AtLeast<O extends object, K extends string> = NoExpand<\n  O extends unknown\n  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n  : never>;\n\ntype _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\nexport type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n/** End Helper Types for \"Merge\" **/\n\nexport type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\nexport type Boolean = True | False\n\nexport type True = 1\n\nexport type False = 0\n\nexport type Not<B extends Boolean> = {\n  0: 1\n  1: 0\n}[B]\n\nexport type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n  ? 0 // anything `never` is false\n  : A1 extends A2\n  ? 1\n  : 0\n\nexport type Has<U extends Union, U1 extends Union> = Not<\n  Extends<Exclude<U1, U>, U1>\n>\n\nexport type Or<B1 extends Boolean, B2 extends Boolean> = {\n  0: {\n    0: 0\n    1: 1\n  }\n  1: {\n    0: 1\n    1: 1\n  }\n}[B1][B2]\n\nexport type Keys<U extends Union> = U extends unknown ? keyof U : never\n\nexport type GetScalarType<T, O> = O extends object ? {\n  [P in keyof T]: P extends keyof O\n    ? O[P]\n    : never\n} : never\n\ntype FieldPaths<\n  T,\n  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n> = IsObject<T> extends True ? U : T\n\nexport type GetHavingFields<T> = {\n  [K in keyof T]: Or<\n    Or<Extends<'OR', K>, Extends<'AND', K>>,\n    Extends<'NOT', K>\n  > extends True\n    ? // infer is only needed to not hit TS limit\n      // based on the brilliant idea of Pierre-Antoine Mills\n      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n      T[K] extends infer TK\n      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n      : never\n    : {} extends FieldPaths<T[K]>\n    ? never\n    : K\n}[keyof T]\n\n/**\n * Convert tuple to union\n */\ntype _TupleToUnion<T> = T extends (infer E)[] ? E : never\ntype TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\nexport type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n/**\n * Like `Pick`, but additionally can also accept an array of keys\n */\nexport type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n/**\n * Exclude all keys with underscores\n */\nexport type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\nexport type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\ntype FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\nexport const ModelName = {\n  User: 'User',\n  Profile: 'Profile',\n  Resume: 'Resume',\n  Interview: 'Interview',\n  Message: 'Message',\n  Score: 'Score',\n  UserAnalytics: 'UserAnalytics',\n  CodingProblem: 'CodingProblem',\n  CodingChallenge: 'CodingChallenge',\n  ChallengeSubmission: 'ChallengeSubmission',\n  ChallengeScore: 'ChallengeScore',\n  CodingTest: 'CodingTest'\n} as const\n\nexport type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n\nexport interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {\n  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>\n}\n\nexport type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n  globalOmitOptions: {\n    omit: GlobalOmitOptions\n  }\n  meta: {\n    modelProps: \"user\" | \"profile\" | \"resume\" | \"interview\" | \"message\" | \"score\" | \"userAnalytics\" | \"codingProblem\" | \"codingChallenge\" | \"challengeSubmission\" | \"challengeScore\" | \"codingTest\"\n    txIsolationLevel: TransactionIsolationLevel\n  }\n  model: {\n    User: {\n      payload: Prisma.$UserPayload<ExtArgs>\n      fields: Prisma.UserFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.UserFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findFirst: {\n          args: Prisma.UserFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        findMany: {\n          args: Prisma.UserFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        create: {\n          args: Prisma.UserCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        createMany: {\n          args: Prisma.UserCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        delete: {\n          args: Prisma.UserDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        update: {\n          args: Prisma.UserUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        deleteMany: {\n          args: Prisma.UserDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.UserUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]\n        }\n        upsert: {\n          args: Prisma.UserUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>\n        }\n        aggregate: {\n          args: Prisma.UserAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>\n        }\n        groupBy: {\n          args: Prisma.UserGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.UserCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number\n        }\n      }\n    }\n    Profile: {\n      payload: Prisma.$ProfilePayload<ExtArgs>\n      fields: Prisma.ProfileFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ProfileFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        findFirst: {\n          args: Prisma.ProfileFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        findMany: {\n          args: Prisma.ProfileFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]\n        }\n        create: {\n          args: Prisma.ProfileCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        createMany: {\n          args: Prisma.ProfileCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]\n        }\n        delete: {\n          args: Prisma.ProfileDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        update: {\n          args: Prisma.ProfileUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        deleteMany: {\n          args: Prisma.ProfileDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ProfileUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[]\n        }\n        upsert: {\n          args: Prisma.ProfileUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>\n        }\n        aggregate: {\n          args: Prisma.ProfileAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateProfile>\n        }\n        groupBy: {\n          args: Prisma.ProfileGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ProfileGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ProfileCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ProfileCountAggregateOutputType> | number\n        }\n      }\n    }\n    Resume: {\n      payload: Prisma.$ResumePayload<ExtArgs>\n      fields: Prisma.ResumeFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ResumeFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ResumeFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        findFirst: {\n          args: Prisma.ResumeFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ResumeFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        findMany: {\n          args: Prisma.ResumeFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>[]\n        }\n        create: {\n          args: Prisma.ResumeCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        createMany: {\n          args: Prisma.ResumeCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ResumeCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>[]\n        }\n        delete: {\n          args: Prisma.ResumeDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        update: {\n          args: Prisma.ResumeUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        deleteMany: {\n          args: Prisma.ResumeDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ResumeUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ResumeUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>[]\n        }\n        upsert: {\n          args: Prisma.ResumeUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResumePayload>\n        }\n        aggregate: {\n          args: Prisma.ResumeAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateResume>\n        }\n        groupBy: {\n          args: Prisma.ResumeGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ResumeGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ResumeCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ResumeCountAggregateOutputType> | number\n        }\n      }\n    }\n    Interview: {\n      payload: Prisma.$InterviewPayload<ExtArgs>\n      fields: Prisma.InterviewFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.InterviewFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.InterviewFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        findFirst: {\n          args: Prisma.InterviewFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.InterviewFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        findMany: {\n          args: Prisma.InterviewFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>[]\n        }\n        create: {\n          args: Prisma.InterviewCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        createMany: {\n          args: Prisma.InterviewCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.InterviewCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>[]\n        }\n        delete: {\n          args: Prisma.InterviewDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        update: {\n          args: Prisma.InterviewUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        deleteMany: {\n          args: Prisma.InterviewDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.InterviewUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.InterviewUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>[]\n        }\n        upsert: {\n          args: Prisma.InterviewUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$InterviewPayload>\n        }\n        aggregate: {\n          args: Prisma.InterviewAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateInterview>\n        }\n        groupBy: {\n          args: Prisma.InterviewGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InterviewGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.InterviewCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.InterviewCountAggregateOutputType> | number\n        }\n      }\n    }\n    Message: {\n      payload: Prisma.$MessagePayload<ExtArgs>\n      fields: Prisma.MessageFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.MessageFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        findFirst: {\n          args: Prisma.MessageFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        findMany: {\n          args: Prisma.MessageFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]\n        }\n        create: {\n          args: Prisma.MessageCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        createMany: {\n          args: Prisma.MessageCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]\n        }\n        delete: {\n          args: Prisma.MessageDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        update: {\n          args: Prisma.MessageUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        deleteMany: {\n          args: Prisma.MessageDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.MessageUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]\n        }\n        upsert: {\n          args: Prisma.MessageUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>\n        }\n        aggregate: {\n          args: Prisma.MessageAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>\n        }\n        groupBy: {\n          args: Prisma.MessageGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.MessageCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number\n        }\n      }\n    }\n    Score: {\n      payload: Prisma.$ScorePayload<ExtArgs>\n      fields: Prisma.ScoreFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ScoreFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ScoreFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        findFirst: {\n          args: Prisma.ScoreFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ScoreFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        findMany: {\n          args: Prisma.ScoreFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>[]\n        }\n        create: {\n          args: Prisma.ScoreCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        createMany: {\n          args: Prisma.ScoreCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ScoreCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>[]\n        }\n        delete: {\n          args: Prisma.ScoreDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        update: {\n          args: Prisma.ScoreUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        deleteMany: {\n          args: Prisma.ScoreDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ScoreUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ScoreUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>[]\n        }\n        upsert: {\n          args: Prisma.ScoreUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ScorePayload>\n        }\n        aggregate: {\n          args: Prisma.ScoreAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateScore>\n        }\n        groupBy: {\n          args: Prisma.ScoreGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScoreGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ScoreCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ScoreCountAggregateOutputType> | number\n        }\n      }\n    }\n    UserAnalytics: {\n      payload: Prisma.$UserAnalyticsPayload<ExtArgs>\n      fields: Prisma.UserAnalyticsFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.UserAnalyticsFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.UserAnalyticsFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        findFirst: {\n          args: Prisma.UserAnalyticsFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.UserAnalyticsFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        findMany: {\n          args: Prisma.UserAnalyticsFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]\n        }\n        create: {\n          args: Prisma.UserAnalyticsCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        createMany: {\n          args: Prisma.UserAnalyticsCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.UserAnalyticsCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]\n        }\n        delete: {\n          args: Prisma.UserAnalyticsDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        update: {\n          args: Prisma.UserAnalyticsUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        deleteMany: {\n          args: Prisma.UserAnalyticsDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.UserAnalyticsUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.UserAnalyticsUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>[]\n        }\n        upsert: {\n          args: Prisma.UserAnalyticsUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAnalyticsPayload>\n        }\n        aggregate: {\n          args: Prisma.UserAnalyticsAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateUserAnalytics>\n        }\n        groupBy: {\n          args: Prisma.UserAnalyticsGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserAnalyticsGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.UserAnalyticsCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.UserAnalyticsCountAggregateOutputType> | number\n        }\n      }\n    }\n    CodingProblem: {\n      payload: Prisma.$CodingProblemPayload<ExtArgs>\n      fields: Prisma.CodingProblemFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.CodingProblemFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.CodingProblemFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        findFirst: {\n          args: Prisma.CodingProblemFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.CodingProblemFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        findMany: {\n          args: Prisma.CodingProblemFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>[]\n        }\n        create: {\n          args: Prisma.CodingProblemCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        createMany: {\n          args: Prisma.CodingProblemCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.CodingProblemCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>[]\n        }\n        delete: {\n          args: Prisma.CodingProblemDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        update: {\n          args: Prisma.CodingProblemUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        deleteMany: {\n          args: Prisma.CodingProblemDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.CodingProblemUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.CodingProblemUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>[]\n        }\n        upsert: {\n          args: Prisma.CodingProblemUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingProblemPayload>\n        }\n        aggregate: {\n          args: Prisma.CodingProblemAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateCodingProblem>\n        }\n        groupBy: {\n          args: Prisma.CodingProblemGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingProblemGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.CodingProblemCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingProblemCountAggregateOutputType> | number\n        }\n      }\n    }\n    CodingChallenge: {\n      payload: Prisma.$CodingChallengePayload<ExtArgs>\n      fields: Prisma.CodingChallengeFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.CodingChallengeFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.CodingChallengeFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        findFirst: {\n          args: Prisma.CodingChallengeFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.CodingChallengeFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        findMany: {\n          args: Prisma.CodingChallengeFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>[]\n        }\n        create: {\n          args: Prisma.CodingChallengeCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        createMany: {\n          args: Prisma.CodingChallengeCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.CodingChallengeCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>[]\n        }\n        delete: {\n          args: Prisma.CodingChallengeDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        update: {\n          args: Prisma.CodingChallengeUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        deleteMany: {\n          args: Prisma.CodingChallengeDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.CodingChallengeUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.CodingChallengeUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>[]\n        }\n        upsert: {\n          args: Prisma.CodingChallengeUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingChallengePayload>\n        }\n        aggregate: {\n          args: Prisma.CodingChallengeAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateCodingChallenge>\n        }\n        groupBy: {\n          args: Prisma.CodingChallengeGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingChallengeGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.CodingChallengeCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingChallengeCountAggregateOutputType> | number\n        }\n      }\n    }\n    ChallengeSubmission: {\n      payload: Prisma.$ChallengeSubmissionPayload<ExtArgs>\n      fields: Prisma.ChallengeSubmissionFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ChallengeSubmissionFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ChallengeSubmissionFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        findFirst: {\n          args: Prisma.ChallengeSubmissionFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ChallengeSubmissionFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        findMany: {\n          args: Prisma.ChallengeSubmissionFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[]\n        }\n        create: {\n          args: Prisma.ChallengeSubmissionCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        createMany: {\n          args: Prisma.ChallengeSubmissionCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ChallengeSubmissionCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[]\n        }\n        delete: {\n          args: Prisma.ChallengeSubmissionDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        update: {\n          args: Prisma.ChallengeSubmissionUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        deleteMany: {\n          args: Prisma.ChallengeSubmissionDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ChallengeSubmissionUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ChallengeSubmissionUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[]\n        }\n        upsert: {\n          args: Prisma.ChallengeSubmissionUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>\n        }\n        aggregate: {\n          args: Prisma.ChallengeSubmissionAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateChallengeSubmission>\n        }\n        groupBy: {\n          args: Prisma.ChallengeSubmissionGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeSubmissionGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ChallengeSubmissionCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeSubmissionCountAggregateOutputType> | number\n        }\n      }\n    }\n    ChallengeScore: {\n      payload: Prisma.$ChallengeScorePayload<ExtArgs>\n      fields: Prisma.ChallengeScoreFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.ChallengeScoreFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.ChallengeScoreFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        findFirst: {\n          args: Prisma.ChallengeScoreFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.ChallengeScoreFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        findMany: {\n          args: Prisma.ChallengeScoreFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]\n        }\n        create: {\n          args: Prisma.ChallengeScoreCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        createMany: {\n          args: Prisma.ChallengeScoreCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.ChallengeScoreCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]\n        }\n        delete: {\n          args: Prisma.ChallengeScoreDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        update: {\n          args: Prisma.ChallengeScoreUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        deleteMany: {\n          args: Prisma.ChallengeScoreDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.ChallengeScoreUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.ChallengeScoreUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>[]\n        }\n        upsert: {\n          args: Prisma.ChallengeScoreUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChallengeScorePayload>\n        }\n        aggregate: {\n          args: Prisma.ChallengeScoreAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateChallengeScore>\n        }\n        groupBy: {\n          args: Prisma.ChallengeScoreGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeScoreGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.ChallengeScoreCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.ChallengeScoreCountAggregateOutputType> | number\n        }\n      }\n    }\n    CodingTest: {\n      payload: Prisma.$CodingTestPayload<ExtArgs>\n      fields: Prisma.CodingTestFieldRefs\n      operations: {\n        findUnique: {\n          args: Prisma.CodingTestFindUniqueArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload> | null\n        }\n        findUniqueOrThrow: {\n          args: Prisma.CodingTestFindUniqueOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        findFirst: {\n          args: Prisma.CodingTestFindFirstArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload> | null\n        }\n        findFirstOrThrow: {\n          args: Prisma.CodingTestFindFirstOrThrowArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        findMany: {\n          args: Prisma.CodingTestFindManyArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>[]\n        }\n        create: {\n          args: Prisma.CodingTestCreateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        createMany: {\n          args: Prisma.CodingTestCreateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        createManyAndReturn: {\n          args: Prisma.CodingTestCreateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>[]\n        }\n        delete: {\n          args: Prisma.CodingTestDeleteArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        update: {\n          args: Prisma.CodingTestUpdateArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        deleteMany: {\n          args: Prisma.CodingTestDeleteManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateMany: {\n          args: Prisma.CodingTestUpdateManyArgs<ExtArgs>\n          result: BatchPayload\n        }\n        updateManyAndReturn: {\n          args: Prisma.CodingTestUpdateManyAndReturnArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>[]\n        }\n        upsert: {\n          args: Prisma.CodingTestUpsertArgs<ExtArgs>\n          result: runtime.Types.Utils.PayloadToResult<Prisma.$CodingTestPayload>\n        }\n        aggregate: {\n          args: Prisma.CodingTestAggregateArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.AggregateCodingTest>\n        }\n        groupBy: {\n          args: Prisma.CodingTestGroupByArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingTestGroupByOutputType>[]\n        }\n        count: {\n          args: Prisma.CodingTestCountArgs<ExtArgs>\n          result: runtime.Types.Utils.Optional<Prisma.CodingTestCountAggregateOutputType> | number\n        }\n      }\n    }\n  }\n} & {\n  other: {\n    payload: any\n    operations: {\n      $executeRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $executeRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n      $queryRaw: {\n        args: [query: TemplateStringsArray | Sql, ...values: any[]],\n        result: any\n      }\n      $queryRawUnsafe: {\n        args: [query: string, ...values: any[]],\n        result: any\n      }\n    }\n  }\n}\n\n/**\n * Enums\n */\n\nexport const TransactionIsolationLevel = runtime.makeStrictEnum({\n  Serializable: 'Serializable'\n} as const)\n\nexport type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\nexport const UserScalarFieldEnum = {\n  id: 'id',\n  email: 'email',\n  password: 'password',\n  name: 'name',\n  avatar: 'avatar',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]\n\n\nexport const ProfileScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  bio: 'bio',\n  yearsExperience: 'yearsExperience',\n  skills: 'skills',\n  targetCompanies: 'targetCompanies',\n  targetRole: 'targetRole',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]\n\n\nexport const ResumeScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  fileName: 'fileName',\n  content: 'content',\n  analysis: 'analysis',\n  filePath: 'filePath',\n  atsScore: 'atsScore',\n  atsBreakdown: 'atsBreakdown',\n  atsFeedback: 'atsFeedback',\n  keywords: 'keywords',\n  softSkills: 'softSkills',\n  predictedRoles: 'predictedRoles',\n  uploadedAt: 'uploadedAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type ResumeScalarFieldEnum = (typeof ResumeScalarFieldEnum)[keyof typeof ResumeScalarFieldEnum]\n\n\nexport const InterviewScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  topic: 'topic',\n  difficulty: 'difficulty',\n  status: 'status',\n  startedAt: 'startedAt',\n  endedAt: 'endedAt',\n  createdAt: 'createdAt',\n  phaseDurations: 'phaseDurations',\n  phaseTransitions: 'phaseTransitions'\n} as const\n\nexport type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]\n\n\nexport const MessageScalarFieldEnum = {\n  id: 'id',\n  interviewId: 'interviewId',\n  role: 'role',\n  content: 'content',\n  timestamp: 'timestamp'\n} as const\n\nexport type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]\n\n\nexport const ScoreScalarFieldEnum = {\n  id: 'id',\n  interviewId: 'interviewId',\n  requirementsClarification: 'requirementsClarification',\n  highLevelDesign: 'highLevelDesign',\n  detailedDesign: 'detailedDesign',\n  scalability: 'scalability',\n  tradeoffs: 'tradeoffs',\n  communication: 'communication',\n  overallScore: 'overallScore',\n  passStatus: 'passStatus',\n  feedback: 'feedback',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type ScoreScalarFieldEnum = (typeof ScoreScalarFieldEnum)[keyof typeof ScoreScalarFieldEnum]\n\n\nexport const UserAnalyticsScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  totalInterviews: 'totalInterviews',\n  completedInterviews: 'completedInterviews',\n  avgOverallScore: 'avgOverallScore',\n  passRate: 'passRate',\n  weakDimensions: 'weakDimensions',\n  strongDimensions: 'strongDimensions',\n  topicStats: 'topicStats',\n  scoreTrend: 'scoreTrend',\n  lastCalculatedAt: 'lastCalculatedAt',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type UserAnalyticsScalarFieldEnum = (typeof UserAnalyticsScalarFieldEnum)[keyof typeof UserAnalyticsScalarFieldEnum]\n\n\nexport const CodingProblemScalarFieldEnum = {\n  id: 'id',\n  title: 'title',\n  description: 'description',\n  difficulty: 'difficulty',\n  category: 'category',\n  companies: 'companies',\n  constraints: 'constraints',\n  examples: 'examples',\n  testCases: 'testCases',\n  solutionApproaches: 'solutionApproaches',\n  starterCode: 'starterCode',\n  timeLimit: 'timeLimit',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type CodingProblemScalarFieldEnum = (typeof CodingProblemScalarFieldEnum)[keyof typeof CodingProblemScalarFieldEnum]\n\n\nexport const CodingChallengeScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  problemId: 'problemId',\n  testId: 'testId',\n  title: 'title',\n  description: 'description',\n  difficulty: 'difficulty',\n  category: 'category',\n  company: 'company',\n  language: 'language',\n  visibleTests: 'visibleTests',\n  hiddenTests: 'hiddenTests',\n  timeLimit: 'timeLimit',\n  status: 'status',\n  startedAt: 'startedAt',\n  endedAt: 'endedAt',\n  starterCode: 'starterCode',\n  finalCode: 'finalCode',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type CodingChallengeScalarFieldEnum = (typeof CodingChallengeScalarFieldEnum)[keyof typeof CodingChallengeScalarFieldEnum]\n\n\nexport const ChallengeSubmissionScalarFieldEnum = {\n  id: 'id',\n  challengeId: 'challengeId',\n  code: 'code',\n  language: 'language',\n  submittedAt: 'submittedAt',\n  evaluation: 'evaluation',\n  testResults: 'testResults',\n  isValid: 'isValid',\n  errorMessage: 'errorMessage'\n} as const\n\nexport type ChallengeSubmissionScalarFieldEnum = (typeof ChallengeSubmissionScalarFieldEnum)[keyof typeof ChallengeSubmissionScalarFieldEnum]\n\n\nexport const ChallengeScoreScalarFieldEnum = {\n  id: 'id',\n  challengeId: 'challengeId',\n  correctness: 'correctness',\n  efficiency: 'efficiency',\n  codeQuality: 'codeQuality',\n  edgeCases: 'edgeCases',\n  overallScore: 'overallScore',\n  passStatus: 'passStatus',\n  feedback: 'feedback',\n  suggestedApproach: 'suggestedApproach',\n  complexityAnalysis: 'complexityAnalysis',\n  createdAt: 'createdAt'\n} as const\n\nexport type ChallengeScoreScalarFieldEnum = (typeof ChallengeScoreScalarFieldEnum)[keyof typeof ChallengeScoreScalarFieldEnum]\n\n\nexport const CodingTestScalarFieldEnum = {\n  id: 'id',\n  userId: 'userId',\n  status: 'status',\n  startedAt: 'startedAt',\n  endedAt: 'endedAt',\n  timeLimit: 'timeLimit',\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt'\n} as const\n\nexport type CodingTestScalarFieldEnum = (typeof CodingTestScalarFieldEnum)[keyof typeof CodingTestScalarFieldEnum]\n\n\nexport const SortOrder = {\n  asc: 'asc',\n  desc: 'desc'\n} as const\n\nexport type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\nexport const NullsOrder = {\n  first: 'first',\n  last: 'last'\n} as const\n\nexport type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n\n/**\n * Field references\n */\n\n\n/**\n * Reference to a field of type 'String'\n */\nexport type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n/**\n * Reference to a field of type 'DateTime'\n */\nexport type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n/**\n * Reference to a field of type 'Int'\n */\nexport type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n/**\n * Reference to a field of type 'Float'\n */\nexport type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n/**\n * Reference to a field of type 'Boolean'\n */\nexport type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>\n    \n\n/**\n * Batch Payload for updateMany & deleteMany & createMany\n */\nexport type BatchPayload = {\n  count: number\n}\n\nexport const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<\"define\", TypeMapCb, runtime.Types.Extensions.DefaultArgs>\nexport type DefaultPrismaClient = PrismaClient\nexport type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\nexport type PrismaClientOptions = ({\n  /**\n   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.\n   */\n  adapter: runtime.SqlDriverAdapterFactory\n  accelerateUrl?: never\n} | {\n  /**\n   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.\n   */\n  accelerateUrl: string\n  adapter?: never\n}) & {\n  /**\n   * @default \"colorless\"\n   */\n  errorFormat?: ErrorFormat\n  /**\n   * @example\n   * ```\n   * // Shorthand for `emit: 'stdout'`\n   * log: ['query', 'info', 'warn', 'error']\n   * \n   * // Emit as events only\n   * log: [\n   *   { emit: 'event', level: 'query' },\n   *   { emit: 'event', level: 'info' },\n   *   { emit: 'event', level: 'warn' }\n   *   { emit: 'event', level: 'error' }\n   * ]\n   * \n   * / Emit as events and log to stdout\n   * og: [\n   *  { emit: 'stdout', level: 'query' },\n   *  { emit: 'stdout', level: 'info' },\n   *  { emit: 'stdout', level: 'warn' }\n   *  { emit: 'stdout', level: 'error' }\n   * \n   * ```\n   * Read more in our [docs](https://pris.ly/d/logging).\n   */\n  log?: (LogLevel | LogDefinition)[]\n  /**\n   * The default values for transactionOptions\n   * maxWait ?= 2000\n   * timeout ?= 5000\n   */\n  transactionOptions?: {\n    maxWait?: number\n    timeout?: number\n    isolationLevel?: TransactionIsolationLevel\n  }\n  /**\n   * Global configuration for omitting model fields by default.\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   omit: {\n   *     user: {\n   *       password: true\n   *     }\n   *   }\n   * })\n   * ```\n   */\n  omit?: GlobalOmitConfig\n  /**\n   * SQL commenter plugins that add metadata to SQL queries as comments.\n   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/\n   * \n   * @example\n   * ```\n   * const prisma = new PrismaClient({\n   *   adapter,\n   *   comments: [\n   *     traceContext(),\n   *     queryInsights(),\n   *   ],\n   * })\n   * ```\n   */\n  comments?: runtime.SqlCommenterPlugin[]\n}\nexport type GlobalOmitConfig = {\n  user?: Prisma.UserOmit\n  profile?: Prisma.ProfileOmit\n  resume?: Prisma.ResumeOmit\n  interview?: Prisma.InterviewOmit\n  message?: Prisma.MessageOmit\n  score?: Prisma.ScoreOmit\n  userAnalytics?: Prisma.UserAnalyticsOmit\n  codingProblem?: Prisma.CodingProblemOmit\n  codingChallenge?: Prisma.CodingChallengeOmit\n  challengeSubmission?: Prisma.ChallengeSubmissionOmit\n  challengeScore?: Prisma.ChallengeScoreOmit\n  codingTest?: Prisma.CodingTestOmit\n}\n\n/* Types for Logging */\nexport type LogLevel = 'info' | 'query' | 'warn' | 'error'\nexport type LogDefinition = {\n  level: LogLevel\n  emit: 'stdout' | 'event'\n}\n\nexport type CheckIsLogLevel<T> = T extends LogLevel ? T : never;\n\nexport type GetLogType<T> = CheckIsLogLevel<\n  T extends LogDefinition ? T['level'] : T\n>;\n\nexport type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>\n  ? GetLogType<T[number]>\n  : never;\n\nexport type QueryEvent = {\n  timestamp: Date\n  query: string\n  params: string\n  duration: number\n  target: string\n}\n\nexport type LogEvent = {\n  timestamp: Date\n  message: string\n  target: string\n}\n/* End Types for Logging */\n\n\nexport type PrismaAction =\n  | 'findUnique'\n  | 'findUniqueOrThrow'\n  | 'findMany'\n  | 'findFirst'\n  | 'findFirstOrThrow'\n  | 'create'\n  | 'createMany'\n  | 'createManyAndReturn'\n  | 'update'\n  | 'updateMany'\n  | 'updateManyAndReturn'\n  | 'upsert'\n  | 'delete'\n  | 'deleteMany'\n  | 'executeRaw'\n  | 'queryRaw'\n  | 'aggregate'\n  | 'count'\n  | 'runCommandRaw'\n  | 'findRaw'\n  | 'groupBy'\n\n/**\n * `PrismaClient` proxy available in interactive transactions.\n */\nexport type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/enums.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n* This file exports all enum related types from the schema.\n*\n* ðŸŸ¢ You can import this file directly.\n*/\n\n\n\n// This file is empty because there are no enums in the schema.\nexport {}\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;AAIA,GAIA,+DAA+D"}},
    {"offset": {"line": 426, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/generated/prisma/client.ts"],"sourcesContent":["\n/* !!! This is code generated by Prisma. Do not edit directly. !!! */\n/* eslint-disable */\n// biome-ignore-all lint: generated file\n// @ts-nocheck \n/*\n * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.\n * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.\n *\n * ðŸŸ¢ You can import this file directly.\n */\n\nimport * as process from 'node:process'\nimport * as path from 'node:path'\nimport { fileURLToPath } from 'node:url'\nglobalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))\n\nimport * as runtime from \"@prisma/client/runtime/client\"\nimport * as $Enums from \"./enums\"\nimport * as $Class from \"./internal/class\"\nimport * as Prisma from \"./internal/prismaNamespace\"\n\nexport * as $Enums from './enums'\nexport * from \"./enums\"\n/**\n * ## Prisma Client\n * \n * Type-safe database client for TypeScript\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.user.findMany()\n * ```\n * \n * Read more in our [docs](https://pris.ly/d/client).\n */\nexport const PrismaClient = $Class.getPrismaClientClass()\nexport type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions[\"omit\"] = Prisma.PrismaClientOptions[\"omit\"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>\nexport { Prisma }\n\n/**\n * Model User\n * \n */\nexport type User = Prisma.UserModel\n/**\n * Model Profile\n * \n */\nexport type Profile = Prisma.ProfileModel\n/**\n * Model Resume\n * \n */\nexport type Resume = Prisma.ResumeModel\n/**\n * Model Interview\n * \n */\nexport type Interview = Prisma.InterviewModel\n/**\n * Model Message\n * \n */\nexport type Message = Prisma.MessageModel\n/**\n * Model Score\n * \n */\nexport type Score = Prisma.ScoreModel\n/**\n * Model UserAnalytics\n * \n */\nexport type UserAnalytics = Prisma.UserAnalyticsModel\n/**\n * Model CodingProblem\n * \n */\nexport type CodingProblem = Prisma.CodingProblemModel\n/**\n * Model CodingChallenge\n * \n */\nexport type CodingChallenge = Prisma.CodingChallengeModel\n/**\n * Model ChallengeSubmission\n * \n */\nexport type ChallengeSubmission = Prisma.ChallengeSubmissionModel\n/**\n * Model ChallengeScore\n * \n */\nexport type ChallengeScore = Prisma.ChallengeScoreModel\n/**\n * Model CodingTest\n * \n */\nexport type CodingTest = Prisma.CodingTestModel\n"],"names":[],"mappings":"AACA,mEAAmE,GACnE,kBAAkB,GAClB,wCAAwC;AACxC,eAAe;AACf;;;;;CAKC;;;;AAGD;AACA;AAKA;AACA;AAEA;;;;;;;;AAPA,UAAU,CAAC,YAAY,GAAG,4HAAY,CAAC,IAAA,gIAAa,EAAC,8BAAY,GAAG;;;;;AAsB7D,MAAM,eAAe,kPAA2B"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"../generated/prisma/client\";\nimport { PrismaLibSql } from \"@prisma/adapter-libsql\";\n\nconst adapter = new PrismaLibSql({\n  url: process.env.DATABASE_URL || \"file:./dev.db\",\n});\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({ adapter });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;;;;;AAEA,MAAM,UAAU,IAAI,kQAAY,CAAC;IAC/B,KAAK,QAAQ,GAAG,CAAC,YAAY,IAAI;AACnC;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,+OAAY,CAAC;IAAE;AAAQ;AAE3E,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 492, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport bcrypt from \"bcryptjs\";\nimport { prisma } from \"./prisma\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  providers: [\n    Credentials({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const email = credentials.email as string;\n        const password = credentials.password as string;\n\n        const user = await prisma.user.findUnique({\n          where: { email },\n        });\n\n        if (!user) {\n          return null;\n        }\n\n        const isPasswordValid = await bcrypt.compare(password, user.password);\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.avatar,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.id = token.id as string;\n      }\n      return session;\n    },\n  },\n  pages: {\n    signIn: \"/login\",\n  },\n  session: {\n    strategy: \"jwt\",\n  },\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;AAEO,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,2OAAQ,EAAC;IAC1D,WAAW;QACT,IAAA,gPAAW,EAAC;YACV,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,QAAQ,YAAY,KAAK;gBAC/B,MAAM,WAAW,YAAY,QAAQ;gBAErC,MAAM,OAAO,MAAM,yMAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE;oBAAM;gBACjB;gBAEA,IAAI,CAAC,MAAM;oBACT,OAAO;gBACT;gBAEA,MAAM,kBAAkB,MAAM,uNAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;gBAEpE,IAAI,CAAC,iBAAiB;oBACpB,OAAO;gBACT;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,OAAO,KAAK,MAAM;gBACpB;YACF;QACF;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YAC5B;YACA,OAAO;QACT;IACF;IACA,OAAO;QACL,QAAQ;IACV;IACA,SAAS;QACP,UAAU;IACZ;AACF"}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/coding/constants.ts"],"sourcesContent":["// Coding Challenge Constants\n\nexport const SUPPORTED_LANGUAGES = {\n  python: { name: \"Python\", extension: \".py\", monacoId: \"python\" },\n  javascript: { name: \"JavaScript\", extension: \".js\", monacoId: \"javascript\" },\n  java: { name: \"Java\", extension: \".java\", monacoId: \"java\" },\n  cpp: { name: \"C++\", extension: \".cpp\", monacoId: \"cpp\" },\n  c: { name: \"C\", extension: \".c\", monacoId: \"c\" },\n  csharp: { name: \"C#\", extension: \".cs\", monacoId: \"csharp\" },\n  go: { name: \"Go\", extension: \".go\", monacoId: \"go\" },\n} as const;\n\nexport type SupportedLanguage = keyof typeof SUPPORTED_LANGUAGES;\n\nexport const PROBLEM_CATEGORIES = [\n  \"arrays\",\n  \"strings\",\n  \"linked-lists\",\n  \"stacks-queues\",\n  \"trees\",\n  \"graphs\",\n  \"dynamic-programming\",\n  \"recursion\",\n  \"sorting-searching\",\n  \"hash-tables\",\n  \"heaps\",\n  \"bit-manipulation\",\n  \"mixed\",\n] as const;\n\nexport type ProblemCategory = typeof PROBLEM_CATEGORIES[number];\n\nexport const CATEGORY_LABELS: Record<ProblemCategory, string> = {\n  \"arrays\": \"Arrays\",\n  \"strings\": \"Strings\",\n  \"linked-lists\": \"Linked Lists\",\n  \"stacks-queues\": \"Stacks & Queues\",\n  \"trees\": \"Trees\",\n  \"graphs\": \"Graphs\",\n  \"dynamic-programming\": \"Dynamic Programming\",\n  \"recursion\": \"Recursion\",\n  \"sorting-searching\": \"Sorting & Searching\",\n  \"hash-tables\": \"Hash Tables\",\n  \"heaps\": \"Heaps\",\n  \"bit-manipulation\": \"Bit Manipulation\",\n  \"mixed\": \"Mixed / Company Pattern\",\n};\n\nexport const COMPANIES = [\n  \"Google\",\n  \"Meta\",\n  \"Amazon\",\n  \"Apple\",\n  \"Microsoft\",\n  \"Netflix\",\n  \"Uber\",\n  \"Airbnb\",\n  \"Stripe\",\n  \"Twitter\",\n  \"LinkedIn\",\n  \"Salesforce\",\n  \"Adobe\",\n  \"Oracle\",\n  \"IBM\",\n  \"Goldman Sachs\",\n  \"JP Morgan\",\n  \"Bloomberg\",\n] as const;\n\nexport type Company = typeof COMPANIES[number];\n\n// Company interview patterns - most asked topics and typical difficulty distribution\nexport interface CompanyInterviewPattern {\n  name: string;\n  topTopics: ProblemCategory[];\n  difficultyDistribution: {\n    easy: number;\n    medium: number;\n    hard: number;\n  };\n  description: string;\n  interviewStyle: string;\n}\n\nexport const COMPANY_PATTERNS: Record<Company, CompanyInterviewPattern> = {\n  \"Google\": {\n    name: \"Google\",\n    topTopics: [\"arrays\", \"strings\", \"trees\", \"graphs\", \"dynamic-programming\"],\n    difficultyDistribution: { easy: 0, medium: 2, hard: 1 },\n    description: \"Focus on algorithmic thinking and optimization\",\n    interviewStyle: \"Emphasizes clean code, optimal solutions, and ability to handle follow-up questions\",\n  },\n  \"Meta\": {\n    name: \"Meta\",\n    topTopics: [\"arrays\", \"strings\", \"trees\", \"graphs\", \"hash-tables\"],\n    difficultyDistribution: { easy: 0, medium: 2, hard: 1 },\n    description: \"Fast-paced coding with emphasis on problem-solving speed\",\n    interviewStyle: \"Values quick thinking, multiple solutions, and handling edge cases\",\n  },\n  \"Amazon\": {\n    name: \"Amazon\",\n    topTopics: [\"arrays\", \"trees\", \"graphs\", \"dynamic-programming\", \"hash-tables\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Leadership principles integrated with coding problems\",\n    interviewStyle: \"Practical problems with real-world applications, emphasis on scalability\",\n  },\n  \"Apple\": {\n    name: \"Apple\",\n    topTopics: [\"arrays\", \"strings\", \"linked-lists\", \"trees\", \"sorting-searching\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Focus on fundamentals and system design thinking\",\n    interviewStyle: \"Clean, maintainable code with attention to detail\",\n  },\n  \"Microsoft\": {\n    name: \"Microsoft\",\n    topTopics: [\"arrays\", \"strings\", \"trees\", \"linked-lists\", \"dynamic-programming\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Well-rounded assessment of CS fundamentals\",\n    interviewStyle: \"Focus on problem decomposition and clear communication\",\n  },\n  \"Netflix\": {\n    name: \"Netflix\",\n    topTopics: [\"arrays\", \"hash-tables\", \"strings\", \"trees\", \"graphs\"],\n    difficultyDistribution: { easy: 0, medium: 2, hard: 1 },\n    description: \"High performance and distributed systems mindset\",\n    interviewStyle: \"Focus on scalability, efficiency, and handling large data\",\n  },\n  \"Uber\": {\n    name: \"Uber\",\n    topTopics: [\"arrays\", \"graphs\", \"hash-tables\", \"heaps\", \"sorting-searching\"],\n    difficultyDistribution: { easy: 0, medium: 2, hard: 1 },\n    description: \"Real-time systems and geospatial problems\",\n    interviewStyle: \"Practical problems related to ride-sharing, maps, and real-time data\",\n  },\n  \"Airbnb\": {\n    name: \"Airbnb\",\n    topTopics: [\"arrays\", \"strings\", \"hash-tables\", \"trees\", \"dynamic-programming\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Product-focused coding with real-world scenarios\",\n    interviewStyle: \"Emphasis on code quality, testing, and product thinking\",\n  },\n  \"Stripe\": {\n    name: \"Stripe\",\n    topTopics: [\"strings\", \"arrays\", \"hash-tables\", \"recursion\", \"dynamic-programming\"],\n    difficultyDistribution: { easy: 0, medium: 2, hard: 1 },\n    description: \"Payment systems and API design focused\",\n    interviewStyle: \"Clean code, error handling, and attention to edge cases in financial systems\",\n  },\n  \"Twitter\": {\n    name: \"Twitter\",\n    topTopics: [\"arrays\", \"strings\", \"hash-tables\", \"heaps\", \"graphs\"],\n    difficultyDistribution: { easy: 0, medium: 2, hard: 1 },\n    description: \"Social network and timeline algorithms\",\n    interviewStyle: \"Focus on data structures for feeds, trending topics, and social graphs\",\n  },\n  \"LinkedIn\": {\n    name: \"LinkedIn\",\n    topTopics: [\"graphs\", \"hash-tables\", \"arrays\", \"trees\", \"strings\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Professional network and recommendation systems\",\n    interviewStyle: \"Graph problems, connection algorithms, and search optimization\",\n  },\n  \"Salesforce\": {\n    name: \"Salesforce\",\n    topTopics: [\"arrays\", \"strings\", \"hash-tables\", \"trees\", \"sorting-searching\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Enterprise software and CRM focused\",\n    interviewStyle: \"Practical problems with emphasis on clean, maintainable code\",\n  },\n  \"Adobe\": {\n    name: \"Adobe\",\n    topTopics: [\"arrays\", \"strings\", \"dynamic-programming\", \"trees\", \"recursion\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Creative software and media processing\",\n    interviewStyle: \"Algorithm optimization and image/document processing scenarios\",\n  },\n  \"Oracle\": {\n    name: \"Oracle\",\n    topTopics: [\"arrays\", \"trees\", \"sorting-searching\", \"hash-tables\", \"strings\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Database and enterprise systems focus\",\n    interviewStyle: \"SQL-related problems and classic data structure questions\",\n  },\n  \"IBM\": {\n    name: \"IBM\",\n    topTopics: [\"arrays\", \"strings\", \"sorting-searching\", \"trees\", \"hash-tables\"],\n    difficultyDistribution: { easy: 2, medium: 1, hard: 0 },\n    description: \"Enterprise solutions and AI/ML applications\",\n    interviewStyle: \"Fundamental CS concepts with emphasis on problem-solving approach\",\n  },\n  \"Goldman Sachs\": {\n    name: \"Goldman Sachs\",\n    topTopics: [\"arrays\", \"strings\", \"dynamic-programming\", \"hash-tables\", \"sorting-searching\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Financial systems and quantitative problems\",\n    interviewStyle: \"Math-heavy problems, optimization, and financial calculations\",\n  },\n  \"JP Morgan\": {\n    name: \"JP Morgan\",\n    topTopics: [\"arrays\", \"strings\", \"hash-tables\", \"sorting-searching\", \"trees\"],\n    difficultyDistribution: { easy: 1, medium: 2, hard: 0 },\n    description: \"Banking systems and transaction processing\",\n    interviewStyle: \"Practical problems with emphasis on accuracy and edge cases\",\n  },\n  \"Bloomberg\": {\n    name: \"Bloomberg\",\n    topTopics: [\"arrays\", \"strings\", \"hash-tables\", \"heaps\", \"sorting-searching\"],\n    difficultyDistribution: { easy: 0, medium: 2, hard: 1 },\n    description: \"Financial data and real-time systems\",\n    interviewStyle: \"Data processing, streaming, and time-series problems\",\n  },\n};\n\nexport const DIFFICULTY_LEVELS = [\"easy\", \"medium\", \"hard\"] as const;\nexport type DifficultyLevel = typeof DIFFICULTY_LEVELS[number];\n\nexport const TIME_LIMITS: Record<DifficultyLevel, number> = {\n  easy: 25,\n  medium: 40,\n  hard: 55,\n};\n\nexport const SCORE_WEIGHTS = {\n  correctness: 0.40,\n  efficiency: 0.25,\n  codeQuality: 0.20,\n  edgeCases: 0.15,\n} as const;\n\nexport const CHALLENGE_STATUS = {\n  PENDING: \"pending\",\n  IN_PROGRESS: \"in_progress\",\n  COMPLETED: \"completed\",\n} as const;\n\nexport type ChallengeStatus = typeof CHALLENGE_STATUS[keyof typeof CHALLENGE_STATUS];\n\n// Test case structure\nexport interface TestCase {\n  input: string;\n  expectedOutput: string;\n  explanation?: string;\n  isHidden?: boolean;\n}\n\n// Example structure\nexport interface Example {\n  input: string;\n  output: string;\n  explanation?: string;\n}\n\n// Score result structure\nexport interface ScoreResult {\n  correctness: number;\n  efficiency: number;\n  codeQuality: number;\n  edgeCases: number;\n  overallScore: number;\n  passStatus: boolean;\n  feedback: string;\n  suggestedApproach?: string;\n  complexityAnalysis?: string;\n}\n\n// Evaluation result structure\nexport interface EvaluationResult {\n  testResults: {\n    testCase: TestCase;\n    passed: boolean;\n    actualOutput?: string;\n    analysis?: string;\n  }[];\n  isValid: boolean;\n  errorMessage?: string;\n  syntaxErrors?: string[];\n  logicAnalysis?: string;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1023, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/ollama-provider.ts"],"sourcesContent":["/**\n * Ollama Provider\n *\n * Handles all Ollama-specific LLM interactions with timeout support.\n */\n\nimport type { LLMMessage, LLMCompletionOptions, LLMResponse, LLMStreamResponse } from \"./index\";\n\nconst OLLAMA_BASE_URL = process.env.OLLAMA_BASE_URL || \"http://localhost:11434\";\nconst OLLAMA_MODEL = process.env.OLLAMA_MODEL || \"llama3\";\nconst OLLAMA_CODE_MODEL = process.env.OLLAMA_CODE_MODEL || \"codellama:7b\";\nconst OLLAMA_TIMEOUT = 30000; // 30 second timeout\n\nexport type OllamaModelType = \"general\" | \"coding\";\n\nfunction getModelForType(type: OllamaModelType): string {\n  return type === \"coding\" ? OLLAMA_CODE_MODEL : OLLAMA_MODEL;\n}\n\n/**\n * Check if Ollama is healthy\n */\nexport async function checkOllamaHealth(): Promise<boolean> {\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 5000);\n\n    const response = await fetch(`${OLLAMA_BASE_URL}/api/tags`, {\n      method: \"GET\",\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeout);\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Non-streaming completion with Ollama\n */\nexport async function ollamaComplete(\n  options: LLMCompletionOptions,\n  modelType: OllamaModelType = \"general\"\n): Promise<LLMResponse> {\n  const model = getModelForType(modelType);\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), OLLAMA_TIMEOUT);\n\n  try {\n    const response = await fetch(`${OLLAMA_BASE_URL}/api/chat`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        model,\n        messages: options.messages,\n        stream: false,\n        options: {\n          temperature: options.temperature ?? 0.7,\n          num_predict: options.maxTokens ?? 800,\n          top_p: options.topP ?? 0.9,\n          stop: options.stop,\n        },\n      }),\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeout);\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Ollama error: ${error}`);\n    }\n\n    const data = await response.json();\n\n    return {\n      content: data.message?.content || \"\",\n      provider: \"ollama\",\n      fallbackUsed: false,\n      model,\n    };\n  } catch (error) {\n    clearTimeout(timeout);\n    throw error;\n  }\n}\n\n/**\n * Streaming completion with Ollama\n */\nexport async function ollamaStreamComplete(\n  options: LLMCompletionOptions,\n  modelType: OllamaModelType = \"general\"\n): Promise<LLMStreamResponse> {\n  const model = getModelForType(modelType);\n\n  const response = await fetch(`${OLLAMA_BASE_URL}/api/chat`, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      model,\n      messages: options.messages,\n      stream: true,\n      options: {\n        temperature: options.temperature ?? 0.7,\n        num_predict: options.maxTokens ?? 800,\n        top_p: options.topP ?? 0.9,\n        stop: options.stop,\n      },\n    }),\n  });\n\n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`Ollama streaming error: ${error}`);\n  }\n\n  if (!response.body) {\n    throw new Error(\"No response body from Ollama\");\n  }\n\n  // Transform Ollama stream to SSE format\n  const stream = transformOllamaStream(response.body);\n\n  return {\n    stream,\n    provider: \"ollama\",\n    fallbackUsed: false,\n    model,\n  };\n}\n\n/**\n * Transform Ollama stream to SSE format\n */\nfunction transformOllamaStream(\n  ollamaStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  let buffer = \"\";\n\n  return new ReadableStream({\n    async start(controller) {\n      const reader = ollamaStream.getReader();\n\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            controller.close();\n            break;\n          }\n\n          buffer += decoder.decode(value, { stream: true });\n\n          // Process complete JSON lines\n          const lines = buffer.split(\"\\n\");\n          buffer = lines.pop() || \"\";\n\n          for (const line of lines) {\n            if (line.trim()) {\n              try {\n                const json = JSON.parse(line);\n                if (json.message?.content) {\n                  const sseData = `data: ${JSON.stringify({ content: json.message.content })}\\n\\n`;\n                  controller.enqueue(encoder.encode(sseData));\n                }\n                if (json.done) {\n                  controller.enqueue(encoder.encode(\"data: [DONE]\\n\\n\"));\n                }\n              } catch {\n                // Skip invalid JSON lines\n              }\n            }\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1182, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/openai-provider.ts"],"sourcesContent":["/**\n * OpenAI Provider\n *\n * Handles all OpenAI-specific LLM interactions as fallback.\n */\n\nimport OpenAI from \"openai\";\nimport type { LLMCompletionOptions, LLMResponse, LLMStreamResponse } from \"./index\";\n\nconst OPENAI_MODEL = process.env.OPENAI_MODEL || \"gpt-4o-mini\";\n\nlet openaiClient: OpenAI | null = null;\n\nfunction getOpenAIClient(): OpenAI {\n  if (!openaiClient) {\n    if (!process.env.OPENAI_API_KEY) {\n      throw new Error(\"OpenAI API key not configured\");\n    }\n    openaiClient = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n    });\n  }\n  return openaiClient;\n}\n\n/**\n * Check if OpenAI is configured\n */\nexport function isOpenAIConfigured(): boolean {\n  return !!process.env.OPENAI_API_KEY;\n}\n\n/**\n * Non-streaming completion with OpenAI\n */\nexport async function openaiComplete(\n  options: LLMCompletionOptions\n): Promise<LLMResponse> {\n  const client = getOpenAIClient();\n\n  const response = await client.chat.completions.create({\n    model: OPENAI_MODEL,\n    messages: options.messages.map((m) => ({\n      role: m.role,\n      content: m.content,\n    })),\n    temperature: options.temperature ?? 0.7,\n    max_tokens: options.maxTokens ?? 800,\n    top_p: options.topP ?? 0.9,\n    stop: options.stop,\n  });\n\n  return {\n    content: response.choices[0]?.message?.content || \"\",\n    provider: \"openai\",\n    fallbackUsed: true,\n    model: OPENAI_MODEL,\n  };\n}\n\n/**\n * Streaming completion with OpenAI\n */\nexport async function openaiStreamComplete(\n  options: LLMCompletionOptions\n): Promise<LLMStreamResponse> {\n  const client = getOpenAIClient();\n\n  const response = await client.chat.completions.create({\n    model: OPENAI_MODEL,\n    messages: options.messages.map((m) => ({\n      role: m.role,\n      content: m.content,\n    })),\n    temperature: options.temperature ?? 0.7,\n    max_tokens: options.maxTokens ?? 800,\n    top_p: options.topP ?? 0.9,\n    stop: options.stop,\n    stream: true,\n  });\n\n  // Transform OpenAI stream to our SSE format\n  const stream = transformOpenAIStream(response);\n\n  return {\n    stream,\n    provider: \"openai\",\n    fallbackUsed: true,\n    model: OPENAI_MODEL,\n  };\n}\n\n/**\n * Transform OpenAI stream to SSE format matching our expected format\n */\nfunction transformOpenAIStream(\n  openaiStream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>\n): ReadableStream<Uint8Array> {\n  const encoder = new TextEncoder();\n\n  return new ReadableStream({\n    async start(controller) {\n      try {\n        for await (const chunk of openaiStream) {\n          const content = chunk.choices[0]?.delta?.content;\n          if (content) {\n            const sseData = `data: ${JSON.stringify({ content })}\\n\\n`;\n            controller.enqueue(encoder.encode(sseData));\n          }\n\n          // Check if this is the final chunk\n          if (chunk.choices[0]?.finish_reason) {\n            controller.enqueue(encoder.encode(\"data: [DONE]\\n\\n\"));\n          }\n        }\n        controller.close();\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;;;CAIC,GAED;AAAA;;AAGA,MAAM,eAAe,QAAQ,GAAG,CAAC,YAAY,IAAI;AAEjD,IAAI,eAA8B;AAElC,SAAS;IACP,IAAI,CAAC,cAAc;QACjB,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;YAC/B,MAAM,IAAI,MAAM;QAClB;QACA,eAAe,IAAI,4PAAM,CAAC;YACxB,QAAQ,QAAQ,GAAG,CAAC,cAAc;QACpC;IACF;IACA,OAAO;AACT;AAKO,SAAS;IACd,OAAO,CAAC,CAAC,QAAQ,GAAG,CAAC,cAAc;AACrC;AAKO,eAAe,eACpB,OAA6B;IAE7B,MAAM,SAAS;IAEf,MAAM,WAAW,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;QACpD,OAAO;QACP,UAAU,QAAQ,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;gBACrC,MAAM,EAAE,IAAI;gBACZ,SAAS,EAAE,OAAO;YACpB,CAAC;QACD,aAAa,QAAQ,WAAW,IAAI;QACpC,YAAY,QAAQ,SAAS,IAAI;QACjC,OAAO,QAAQ,IAAI,IAAI;QACvB,MAAM,QAAQ,IAAI;IACpB;IAEA,OAAO;QACL,SAAS,SAAS,OAAO,CAAC,EAAE,EAAE,SAAS,WAAW;QAClD,UAAU;QACV,cAAc;QACd,OAAO;IACT;AACF;AAKO,eAAe,qBACpB,OAA6B;IAE7B,MAAM,SAAS;IAEf,MAAM,WAAW,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;QACpD,OAAO;QACP,UAAU,QAAQ,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;gBACrC,MAAM,EAAE,IAAI;gBACZ,SAAS,EAAE,OAAO;YACpB,CAAC;QACD,aAAa,QAAQ,WAAW,IAAI;QACpC,YAAY,QAAQ,SAAS,IAAI;QACjC,OAAO,QAAQ,IAAI,IAAI;QACvB,MAAM,QAAQ,IAAI;QAClB,QAAQ;IACV;IAEA,4CAA4C;IAC5C,MAAM,SAAS,sBAAsB;IAErC,OAAO;QACL;QACA,UAAU;QACV,cAAc;QACd,OAAO;IACT;AACF;AAEA;;CAEC,GACD,SAAS,sBACP,YAAwE;IAExE,MAAM,UAAU,IAAI;IAEpB,OAAO,IAAI,eAAe;QACxB,MAAM,OAAM,UAAU;YACpB,IAAI;gBACF,WAAW,MAAM,SAAS,aAAc;oBACtC,MAAM,UAAU,MAAM,OAAO,CAAC,EAAE,EAAE,OAAO;oBACzC,IAAI,SAAS;wBACX,MAAM,UAAU,CAAC,MAAM,EAAE,KAAK,SAAS,CAAC;4BAAE;wBAAQ,GAAG,IAAI,CAAC;wBAC1D,WAAW,OAAO,CAAC,QAAQ,MAAM,CAAC;oBACpC;oBAEA,mCAAmC;oBACnC,IAAI,MAAM,OAAO,CAAC,EAAE,EAAE,eAAe;wBACnC,WAAW,OAAO,CAAC,QAAQ,MAAM,CAAC;oBACpC;gBACF;gBACA,WAAW,KAAK;YAClB,EAAE,OAAO,OAAO;gBACd,WAAW,KAAK,CAAC;YACnB;QACF;IACF;AACF"}},
    {"offset": {"line": 1287, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/client.ts"],"sourcesContent":["/**\n * Unified LLM Client\n *\n * Provides a unified interface for LLM operations with automatic\n * fallback from Ollama to OpenAI when Ollama is unavailable.\n */\n\nimport type {\n  LLMCompletionOptions,\n  LLMResponse,\n  LLMStreamResponse,\n  ModelType,\n} from \"./index\";\nimport {\n  checkOllamaHealth,\n  ollamaComplete,\n  ollamaStreamComplete,\n  type OllamaModelType,\n} from \"./ollama-provider\";\nimport {\n  isOpenAIConfigured,\n  openaiComplete,\n  openaiStreamComplete,\n} from \"./openai-provider\";\nimport { getOrFetch } from \"@/lib/cache\";\nimport { CACHE_KEYS, CACHE_TTL } from \"@/lib/redis\";\n\n/**\n * Check LLM health with caching\n */\nexport async function checkLLMHealth(): Promise<{\n  ollamaAvailable: boolean;\n  openaiConfigured: boolean;\n}> {\n  // Always check fresh status (no caching) to handle \"resetting\" scenarios\n  const ollamaAvailable = await checkOllamaHealth();\n\n  return {\n    ollamaAvailable,\n    openaiConfigured: isOpenAIConfigured(),\n  };\n}\n\n/**\n * Non-streaming completion with automatic fallback\n */\nexport async function complete(\n  options: LLMCompletionOptions,\n  modelType: ModelType = \"general\"\n): Promise<LLMResponse> {\n  // Check Ollama health (cached)\n  const health = await checkLLMHealth();\n\n  // Try Ollama first if available\n  if (health.ollamaAvailable) {\n    try {\n      console.log(\"[LLM] Attempting Ollama completion...\");\n      const response = await ollamaComplete(\n        options,\n        modelType as OllamaModelType\n      );\n      console.log(\"[LLM] Ollama completion successful\");\n      return response;\n    } catch (error) {\n      console.warn(\"[LLM] Ollama failed, checking fallback:\", error);\n    }\n  }\n\n  // Fallback to OpenAI\n  if (health.openaiConfigured) {\n    console.log(\"[LLM] Falling back to OpenAI...\");\n    const response = await openaiComplete(options);\n    console.log(\"[LLM] OpenAI completion successful\");\n    return response;\n  }\n\n  throw new Error(\n    \"No LLM provider available. Ollama is not running and OpenAI is not configured.\"\n  );\n}\n\n/**\n * Streaming completion with automatic fallback\n */\nexport async function streamComplete(\n  options: LLMCompletionOptions,\n  modelType: ModelType = \"general\"\n): Promise<LLMStreamResponse> {\n  // Check Ollama health (cached)\n  const health = await checkLLMHealth();\n\n  // Try Ollama first if available\n  if (health.ollamaAvailable) {\n    try {\n      console.log(\"[LLM] Attempting Ollama streaming...\");\n      const response = await ollamaStreamComplete(\n        options,\n        modelType as OllamaModelType\n      );\n      console.log(\"[LLM] Ollama streaming started\");\n      return response;\n    } catch (error) {\n      console.warn(\"[LLM] Ollama streaming failed, checking fallback:\", error);\n    }\n  }\n\n  // Fallback to OpenAI\n  if (health.openaiConfigured) {\n    console.log(\"[LLM] Falling back to OpenAI streaming...\");\n    const response = await openaiStreamComplete(options);\n    console.log(\"[LLM] OpenAI streaming started\");\n    return response;\n  }\n\n  throw new Error(\n    \"No LLM provider available. Ollama is not running and OpenAI is not configured.\"\n  );\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;AAQD;AAMA;;;AAWO,eAAe;IAIpB,yEAAyE;IACzE,MAAM,kBAAkB,MAAM,IAAA,uOAAiB;IAE/C,OAAO;QACL;QACA,kBAAkB,IAAA,wOAAkB;IACtC;AACF;AAKO,eAAe,SACpB,OAA6B,EAC7B,YAAuB,SAAS;IAEhC,+BAA+B;IAC/B,MAAM,SAAS,MAAM;IAErB,gCAAgC;IAChC,IAAI,OAAO,eAAe,EAAE;QAC1B,IAAI;YACF,QAAQ,GAAG,CAAC;YACZ,MAAM,WAAW,MAAM,IAAA,oOAAc,EACnC,SACA;YAEF,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,2CAA2C;QAC1D;IACF;IAEA,qBAAqB;IACrB,IAAI,OAAO,gBAAgB,EAAE;QAC3B,QAAQ,GAAG,CAAC;QACZ,MAAM,WAAW,MAAM,IAAA,oOAAc,EAAC;QACtC,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT;IAEA,MAAM,IAAI,MACR;AAEJ;AAKO,eAAe,eACpB,OAA6B,EAC7B,YAAuB,SAAS;IAEhC,+BAA+B;IAC/B,MAAM,SAAS,MAAM;IAErB,gCAAgC;IAChC,IAAI,OAAO,eAAe,EAAE;QAC1B,IAAI;YACF,QAAQ,GAAG,CAAC;YACZ,MAAM,WAAW,MAAM,IAAA,0OAAoB,EACzC,SACA;YAEF,QAAQ,GAAG,CAAC;YACZ,OAAO;QACT,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,qDAAqD;QACpE;IACF;IAEA,qBAAqB;IACrB,IAAI,OAAO,gBAAgB,EAAE;QAC3B,QAAQ,GAAG,CAAC;QACZ,MAAM,WAAW,MAAM,IAAA,0OAAoB,EAAC;QAC5C,QAAQ,GAAG,CAAC;QACZ,OAAO;IACT;IAEA,MAAM,IAAI,MACR;AAEJ"}},
    {"offset": {"line": 1362, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/llm/index.ts"],"sourcesContent":["/**\n * LLM Types and Interfaces\n *\n * Unified type definitions for LLM interactions.\n */\n\nexport interface LLMMessage {\n  role: \"system\" | \"user\" | \"assistant\";\n  content: string;\n}\n\nexport interface LLMCompletionOptions {\n  messages: LLMMessage[];\n  temperature?: number;\n  maxTokens?: number;\n  topP?: number;\n  stop?: string[];\n  stream?: boolean;\n}\n\nexport interface LLMResponse {\n  content: string;\n  provider: \"ollama\" | \"openai\";\n  fallbackUsed: boolean;\n  model: string;\n}\n\nexport interface LLMStreamResponse {\n  stream: ReadableStream<Uint8Array>;\n  provider: \"ollama\" | \"openai\";\n  fallbackUsed: boolean;\n  model: string;\n}\n\nexport type ModelType = \"general\" | \"coding\";\n\n// Re-export client functions\nexport { complete, streamComplete, checkLLMHealth } from \"./client\";\n"],"names":[],"mappings":"AAAA;;;;CAIC;AAgCD,6BAA6B;AAC7B"}},
    {"offset": {"line": 1374, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/prompts/coding.ts"],"sourcesContent":["// LLM Prompts for Coding Challenges\n\nexport const PROBLEM_GENERATION_PROMPT = `You are an expert DSA problem designer for technical interviews at top tech companies.\n\nGenerate a coding problem based on the following specifications:\n- Difficulty: {difficulty}\n- Category: {category}\n- Company Style: {company} (if provided, match their interview style)\n\nYour response MUST be a valid JSON object with this exact structure:\n{\n  \"title\": \"Problem Title\",\n  \"description\": \"Detailed problem description explaining what needs to be solved. Include the goal, any important definitions, and what the function should return.\",\n  \"constraints\": [\n    \"1 <= n <= 10^5\",\n    \"Array contains integers from -10^9 to 10^9\",\n    \"etc.\"\n  ],\n  \"examples\": [\n    {\n      \"input\": \"nums = [1, 2, 3], target = 4\",\n      \"output\": \"[0, 2]\",\n      \"explanation\": \"Because nums[0] + nums[2] = 1 + 3 = 4\"\n    }\n  ],\n  \"visibleTestCases\": [\n    {\n      \"input\": \"[1, 2, 3]\\\\n4\",\n      \"expectedOutput\": \"[0, 2]\",\n      \"explanation\": \"Basic case\"\n    }\n  ],\n  \"hiddenTestCases\": [\n    {\n      \"input\": \"[1, 1, 1]\\\\n2\",\n      \"expectedOutput\": \"[0, 1]\",\n      \"explanation\": \"Duplicate values\"\n    }\n  ],\n  \"solutionApproaches\": [\n    \"Brute Force: O(n^2) time, O(1) space - Check all pairs\",\n    \"Hash Map: O(n) time, O(n) space - Store complements\"\n  ],\n  \"expectedComplexity\": {\n    \"time\": \"O(n)\",\n    \"space\": \"O(n)\"\n  }\n}\n\nRequirements:\n1. Create a realistic interview problem appropriate for the difficulty level\n2. Include 2-3 visible test cases that demonstrate the problem\n3. Include 3-5 hidden test cases covering edge cases (empty input, single element, large values, etc.)\n4. Provide clear constraints\n5. The problem should be solvable in 30-60 minutes depending on difficulty\n6. For easy: fundamental data structure operations\n7. For medium: combination of techniques, optimization needed\n8. For hard: complex algorithms, multiple steps, non-obvious solutions\n\nReturn ONLY the JSON object, no additional text.`;\n\nexport const CODE_EVALUATION_PROMPT = `You are an expert code reviewer and algorithm analyzer. Your task is to evaluate a candidate's code solution WITHOUT executing it.\n\nProblem:\n{problemDescription}\n\nTest Cases:\n{testCases}\n\nCandidate's Code ({language}):\n\\`\\`\\`{language}\n{code}\n\\`\\`\\`\n\nAnalyze the code and provide your evaluation as a JSON object:\n{\n  \"testResults\": [\n    {\n      \"testIndex\": 0,\n      \"input\": \"test input\",\n      \"expectedOutput\": \"expected\",\n      \"predictedOutput\": \"what the code would output\",\n      \"passed\": true/false,\n      \"analysis\": \"Brief explanation of why it passes or fails\"\n    }\n  ],\n  \"syntaxValid\": true/false,\n  \"syntaxErrors\": [\"list any syntax errors found\"],\n  \"logicAnalysis\": \"Detailed analysis of the algorithm's logic and correctness\",\n  \"correctness\": 0-100,\n  \"efficiency\": 0-100,\n  \"codeQuality\": 0-100,\n  \"edgeCases\": 0-100,\n  \"feedback\": \"Detailed constructive feedback about the solution\",\n  \"suggestedApproach\": \"If the solution is suboptimal, describe a better approach\",\n  \"complexityAnalysis\": {\n    \"time\": \"O(n^2)\",\n    \"space\": \"O(1)\",\n    \"explanation\": \"Loop within a loop for each element...\"\n  }\n}\n\nScoring Guidelines:\n\nCORRECTNESS (0-100):\n- 100: All test cases pass with correct logic\n- 80-99: Minor issues, most cases pass\n- 50-79: Some test cases fail, partial logic\n- 20-49: Significant logic errors\n- 0-19: Fundamentally incorrect approach\n\nEFFICIENCY (0-100):\n- 100: Optimal time and space complexity\n- 80-99: Near-optimal, minor improvements possible\n- 50-79: Acceptable but not optimal\n- 20-49: Inefficient solution\n- 0-19: Very poor complexity (exponential when polynomial exists)\n\nCODE QUALITY (0-100):\n- Clean, readable code with good variable names\n- Proper indentation and structure\n- No code duplication\n- Appropriate use of language features\n- Comments where needed (but not excessive)\n\nEDGE CASES (0-100):\n- Handles empty/null inputs\n- Handles single elements\n- Handles boundary values\n- Handles duplicate values\n- Handles negative numbers (if applicable)\n\nReturn ONLY the JSON object, no additional text.\n\nCRITICAL EVALUATION RULES:\n1. If the code is just a function definition with 'pass', 'return', 'return null', or an empty body: SCORE 0 for Correctness, Efficiency, and Edge Cases.\n2. If the code is a placeholder (e.g. \"// TODO\", \"# Write code here\"): SCORE 0.\n3. You must verify if the code actually implements an algorithm to solve the problem. If it hardcodes return values for test cases without a general logic, SCORE 0.\n4. If the code contains only the starter template: SCORE 0.`;\n\nexport const TEST_CASE_GENERATION_PROMPT = `You are an expert test engineer. Generate additional test cases for the following coding problem.\n\nProblem:\n{problemDescription}\n\nExisting Test Cases:\n{existingTestCases}\n\nGenerate {count} additional test cases that cover edge cases and scenarios not yet tested.\n\nYour response MUST be a valid JSON array:\n[\n  {\n    \"input\": \"test input formatted for the problem\",\n    \"expectedOutput\": \"expected output\",\n    \"explanation\": \"What this test case is checking\",\n    \"isHidden\": true\n  }\n]\n\nFocus on:\n1. Empty inputs\n2. Single element inputs\n3. Maximum constraint values\n4. Minimum constraint values\n5. Negative numbers (if applicable)\n6. Duplicate values\n7. All same values\n8. Sorted input (ascending and descending)\n9. Random order\n10. Boundary conditions\n\nReturn ONLY the JSON array, no additional text.`;\n\nexport const STARTER_CODE_GENERATION_PROMPT = `Generate starter code templates for the following problem in {language}:\n\nProblem: {title}\nDescription: {description}\n\nThe starter code should:\n1. Include the main function signature with appropriate parameters and return type\n2. Include helpful comments about input/output format\n3. Be ready for the candidate to implement the solution\n4. Use idiomatic {language} conventions\n\nReturn ONLY the code, no explanations.`;\n"],"names":[],"mappings":"AAAA,oCAAoC;;;;;;;;;;;AAE7B,MAAM,4BAA4B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gDAyDM,CAAC;AAE1C,MAAM,yBAAyB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2DA6EoB,CAAC;AAErD,MAAM,8BAA8B,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;+CAgCG,CAAC;AAEzC,MAAM,iCAAiC,CAAC;;;;;;;;;;;sCAWT,CAAC"}},
    {"offset": {"line": 1570, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/coding/problem-generator.ts"],"sourcesContent":["// Problem Generator using LLM (Ollama with OpenAI fallback)\n// Supports CodeLlama for code generation and understanding\n\nimport { complete, type LLMMessage } from \"@/lib/llm\";\nimport {\n  PROBLEM_GENERATION_PROMPT,\n  TEST_CASE_GENERATION_PROMPT,\n} from \"@/lib/prompts/coding\";\nimport { DifficultyLevel, ProblemCategory, TestCase } from \"./constants\";\n\nexport interface GeneratedProblem {\n  title: string;\n  description: string;\n  constraints: string[];\n  examples: {\n    input: string;\n    output: string;\n    explanation?: string;\n  }[];\n  visibleTestCases: TestCase[];\n  hiddenTestCases: TestCase[];\n  solutionApproaches: string[];\n  expectedComplexity: {\n    time: string;\n    space: string;\n  };\n}\n\nexport interface ProblemGenerationInput {\n  difficulty: DifficultyLevel;\n  category: ProblemCategory;\n  company?: string;\n  model?: \"codellama\" | \"llama3\";\n}\n\n/**\n * Generate a coding problem using LLM (Ollama with OpenAI fallback)\n * Uses coding model type when available\n */\nexport async function generateCodingProblem(\n  input: ProblemGenerationInput\n): Promise<GeneratedProblem> {\n  const prompt = PROBLEM_GENERATION_PROMPT\n    .replace(\"{difficulty}\", input.difficulty)\n    .replace(\"{category}\", input.category)\n    .replace(\"{company}\", input.company || \"general tech company\");\n\n  const messages: LLMMessage[] = [\n    {\n      role: \"user\",\n      content: prompt,\n    },\n  ];\n\n  // Use coding model for codellama preference, general for llama3\n  const modelType = input.model === \"llama3\" ? \"general\" : \"coding\";\n\n  const response = await complete(\n    {\n      messages,\n      temperature: 0.8,\n      maxTokens: 2000,\n    },\n    modelType\n  );\n\n  const content = response.content;\n\n  // Parse the JSON response\n  try {\n    // Find JSON in the response (in case there's extra text)\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error(\"No JSON object found in response\");\n    }\n\n    const parsed = JSON.parse(jsonMatch[0]);\n\n    // Validate required fields\n    if (!parsed.title || !parsed.description) {\n      throw new Error(\"Missing required fields in generated problem\");\n    }\n\n    return {\n      title: parsed.title,\n      description: parsed.description,\n      constraints: parsed.constraints || [],\n      examples: parsed.examples || [],\n      visibleTestCases: (parsed.visibleTestCases || []).map((tc: TestCase) => ({\n        ...tc,\n        isHidden: false,\n      })),\n      hiddenTestCases: (parsed.hiddenTestCases || []).map((tc: TestCase) => ({\n        ...tc,\n        isHidden: true,\n      })),\n      solutionApproaches: parsed.solutionApproaches || [],\n      expectedComplexity: parsed.expectedComplexity || { time: \"Unknown\", space: \"Unknown\" },\n    };\n  } catch (error) {\n    console.error(\"Failed to parse problem generation response:\", error);\n    console.error(\"Raw response:\", content);\n    throw new Error(\"Failed to generate problem. Please try again.\");\n  }\n}\n\n/**\n * Generate additional hidden test cases for a problem\n */\nexport async function generateHiddenTestCases(\n  problemDescription: string,\n  existingTestCases: TestCase[],\n  count: number = 5\n): Promise<TestCase[]> {\n  const prompt = TEST_CASE_GENERATION_PROMPT\n    .replace(\"{problemDescription}\", problemDescription)\n    .replace(\"{existingTestCases}\", JSON.stringify(existingTestCases, null, 2))\n    .replace(\"{count}\", count.toString());\n\n  const messages: LLMMessage[] = [\n    {\n      role: \"user\",\n      content: prompt,\n    },\n  ];\n\n  // Use coding model type for test case generation\n  const response = await complete(\n    {\n      messages,\n      temperature: 0.7,\n      maxTokens: 1500,\n    },\n    \"coding\"\n  );\n\n  const content = response.content;\n\n  try {\n    // Find JSON array in the response\n    const jsonMatch = content.match(/\\[[\\s\\S]*\\]/);\n    if (!jsonMatch) {\n      throw new Error(\"No JSON array found in response\");\n    }\n\n    const parsed = JSON.parse(jsonMatch[0]);\n\n    return parsed.map((tc: TestCase) => ({\n      input: tc.input,\n      expectedOutput: tc.expectedOutput,\n      explanation: tc.explanation,\n      isHidden: true,\n    }));\n  } catch (error) {\n    console.error(\"Failed to parse test case generation response:\", error);\n    // Return empty array on failure\n    return [];\n  }\n}\n\n/**\n * Format problem description for display\n */\nexport function formatProblemDescription(problem: GeneratedProblem): string {\n  let description = `# ${problem.title}\\n\\n`;\n  description += `${problem.description}\\n\\n`;\n\n  if (problem.constraints.length > 0) {\n    description += `## Constraints\\n\\n`;\n    problem.constraints.forEach(c => {\n      description += `- ${c}\\n`;\n    });\n    description += \"\\n\";\n  }\n\n  if (problem.examples.length > 0) {\n    description += `## Examples\\n\\n`;\n    problem.examples.forEach((ex, i) => {\n      description += `### Example ${i + 1}\\n`;\n      description += `**Input:** ${ex.input}\\n`;\n      description += `**Output:** ${ex.output}\\n`;\n      if (ex.explanation) {\n        description += `**Explanation:** ${ex.explanation}\\n`;\n      }\n      description += \"\\n\";\n    });\n  }\n\n  return description;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1700, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/coding/code-evaluator.ts"],"sourcesContent":["// Code Evaluator using LLM (Ollama with OpenAI fallback)\n// Uses coding model type for code understanding and analysis\n\nimport { complete, type LLMMessage } from \"@/lib/llm\";\nimport { CODE_EVALUATION_PROMPT } from \"@/lib/prompts/coding\";\nimport {\n  TestCase,\n  EvaluationResult,\n  ScoreResult,\n  SCORE_WEIGHTS,\n  SupportedLanguage,\n} from \"./constants\";\n\nexport interface EvaluationInput {\n  code: string;\n  language: SupportedLanguage;\n  problemDescription: string;\n  testCases: TestCase[];\n}\n\nexport interface TestResult {\n  testIndex: number;\n  input: string;\n  expectedOutput: string;\n  predictedOutput: string;\n  passed: boolean;\n  analysis: string;\n}\n\nexport interface RawEvaluationResult {\n  testResults: TestResult[];\n  syntaxValid: boolean;\n  syntaxErrors: string[];\n  logicAnalysis: string;\n  correctness: number;\n  efficiency: number;\n  codeQuality: number;\n  edgeCases: number;\n  feedback: string;\n  suggestedApproach?: string;\n  complexityAnalysis?: {\n    time: string;\n    space: string;\n    explanation: string;\n  };\n}\n\n/**\n * Evaluate code using LLM (Ollama with OpenAI fallback)\n * Uses coding model type for accurate code understanding and analysis\n */\nexport async function evaluateCode(\n  input: EvaluationInput\n): Promise<RawEvaluationResult> {\n  const prompt = CODE_EVALUATION_PROMPT\n    .replace(\"{problemDescription}\", input.problemDescription)\n    .replace(\"{testCases}\", JSON.stringify(input.testCases, null, 2))\n    .replace(/{language}/g, input.language)\n    .replace(\"{code}\", input.code);\n\n  const messages: LLMMessage[] = [\n    {\n      role: \"user\",\n      content: prompt,\n    },\n  ];\n\n  // Use coding model type for accurate code analysis and evaluation\n  const response = await complete(\n    {\n      messages,\n      temperature: 0.3, // Lower temperature for more consistent evaluation\n      maxTokens: 3000,\n    },\n    \"coding\"\n  );\n\n  const content = response.content;\n\n  try {\n    // Find JSON in the response\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (!jsonMatch) {\n      throw new Error(\"No JSON object found in evaluation response\");\n    }\n\n    const parsed = JSON.parse(jsonMatch[0]);\n\n    return {\n      testResults: parsed.testResults || [],\n      syntaxValid: parsed.syntaxValid ?? true,\n      syntaxErrors: parsed.syntaxErrors || [],\n      logicAnalysis: parsed.logicAnalysis || \"\",\n      correctness: Math.min(100, Math.max(0, parsed.correctness || 0)),\n      efficiency: Math.min(100, Math.max(0, parsed.efficiency || 0)),\n      codeQuality: Math.min(100, Math.max(0, parsed.codeQuality || 0)),\n      edgeCases: Math.min(100, Math.max(0, parsed.edgeCases || 0)),\n      feedback: parsed.feedback || \"No feedback available.\",\n      suggestedApproach: parsed.suggestedApproach,\n      complexityAnalysis: parsed.complexityAnalysis,\n    };\n  } catch (error) {\n    console.error(\"Failed to parse evaluation response:\", error);\n    console.error(\"Raw response:\", content);\n\n    // Return a default evaluation on parse failure\n    return {\n      testResults: [],\n      syntaxValid: false,\n      syntaxErrors: [\"Unable to evaluate code - please check syntax\"],\n      logicAnalysis: \"Evaluation failed due to parsing error.\",\n      correctness: 0,\n      efficiency: 0,\n      codeQuality: 0,\n      edgeCases: 0,\n      feedback: \"Unable to evaluate the code. Please ensure the code is syntactically correct and try again.\",\n      suggestedApproach: undefined,\n      complexityAnalysis: undefined,\n    };\n  }\n}\n\n/**\n * Convert raw evaluation to EvaluationResult format\n */\nexport function toEvaluationResult(\n  raw: RawEvaluationResult,\n  testCases: TestCase[]\n): EvaluationResult {\n  return {\n    testResults: testCases.map((tc, index) => {\n      const result = raw.testResults.find(r => r.testIndex === index);\n      return {\n        testCase: tc,\n        passed: result?.passed ?? false,\n        actualOutput: result?.predictedOutput,\n        analysis: result?.analysis,\n      };\n    }),\n    isValid: raw.syntaxValid,\n    errorMessage: raw.syntaxErrors.length > 0 ? raw.syntaxErrors.join(\"; \") : undefined,\n    syntaxErrors: raw.syntaxErrors,\n    logicAnalysis: raw.logicAnalysis,\n  };\n}\n\n/**\n * Calculate final score from evaluation\n */\nexport function calculateScore(evaluation: RawEvaluationResult): ScoreResult {\n  // Normalize scores from 0-100 to 0-1\n  const correctnessNorm = evaluation.correctness / 100;\n  const efficiencyNorm = evaluation.efficiency / 100;\n  const codeQualityNorm = evaluation.codeQuality / 100;\n  const edgeCasesNorm = evaluation.edgeCases / 100;\n\n  // Calculate weighted overall score\n  const overallScore =\n    correctnessNorm * SCORE_WEIGHTS.correctness +\n    efficiencyNorm * SCORE_WEIGHTS.efficiency +\n    codeQualityNorm * SCORE_WEIGHTS.codeQuality +\n    edgeCasesNorm * SCORE_WEIGHTS.edgeCases;\n\n  // Pass if overall score >= 70% and correctness >= 60%\n  const passStatus = overallScore >= 0.70 && correctnessNorm >= 0.60;\n\n  return {\n    correctness: evaluation.correctness,\n    efficiency: evaluation.efficiency,\n    codeQuality: evaluation.codeQuality,\n    edgeCases: evaluation.edgeCases,\n    overallScore: Math.round(overallScore * 100),\n    passStatus,\n    feedback: evaluation.feedback,\n    suggestedApproach: evaluation.suggestedApproach,\n    complexityAnalysis: evaluation.complexityAnalysis\n      ? `Time: ${evaluation.complexityAnalysis.time}, Space: ${evaluation.complexityAnalysis.space}. ${evaluation.complexityAnalysis.explanation}`\n      : undefined,\n  };\n}\n\n/**\n * Quick syntax check (basic validation before full evaluation)\n */\nexport function quickSyntaxCheck(code: string, language: SupportedLanguage): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!code.trim()) {\n    errors.push(\"Code is empty\");\n    return { valid: false, errors };\n  }\n\n  // Basic bracket matching\n  const brackets: Record<string, string> = { \"(\": \")\", \"[\": \"]\", \"{\": \"}\" };\n  const stack: string[] = [];\n\n  for (const char of code) {\n    if (char in brackets) {\n      stack.push(brackets[char]);\n    } else if (Object.values(brackets).includes(char)) {\n      if (stack.pop() !== char) {\n        errors.push(\"Unmatched brackets detected\");\n        break;\n      }\n    }\n  }\n\n  if (stack.length > 0 && errors.length === 0) {\n    errors.push(\"Unclosed brackets detected\");\n  }\n\n  // Language-specific checks\n  if (language === \"python\") {\n    // Check for common Python syntax issues\n    if (code.includes(\"def \") && !code.includes(\":\")) {\n      errors.push(\"Missing colon after function definition\");\n    }\n  } else if (language === \"java\" || language === \"csharp\" || language === \"cpp\" || language === \"c\") {\n    // Check for missing semicolons (rough heuristic)\n    const lines = code.split(\"\\n\");\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (\n        line.length > 0 &&\n        !line.endsWith(\"{\") &&\n        !line.endsWith(\"}\") &&\n        !line.endsWith(\";\") &&\n        !line.endsWith(\",\") &&\n        !line.startsWith(\"//\") &&\n        !line.startsWith(\"/*\") &&\n        !line.startsWith(\"*\") &&\n        !line.startsWith(\"#\") &&\n        !line.includes(\"if\") &&\n        !line.includes(\"for\") &&\n        !line.includes(\"while\") &&\n        !line.includes(\"else\")\n      ) {\n        // This is a rough check, actual syntax validation is done by the AI\n      }\n    }\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1868, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/coding/starter-templates.ts"],"sourcesContent":["// Language-specific starter code templates\n\nimport { SupportedLanguage, ProblemCategory } from \"./constants\";\n\n/**\n * Get starter code template for a given language and problem type\n */\nexport function getStarterTemplate(\n  language: SupportedLanguage,\n  problemTitle: string,\n  category: ProblemCategory\n): string {\n  const templates: Record<SupportedLanguage, string> = {\n    python: getPythonTemplate(problemTitle, category),\n    javascript: getJavaScriptTemplate(problemTitle, category),\n    java: getJavaTemplate(problemTitle, category),\n    cpp: getCppTemplate(problemTitle, category),\n    c: getCTemplate(problemTitle, category),\n    csharp: getCSharpTemplate(problemTitle, category),\n    go: getGoTemplate(problemTitle, category),\n  };\n\n  return templates[language];\n}\n\nfunction getPythonTemplate(title: string, category: ProblemCategory): string {\n  const functionName = toSnakeCase(title);\n\n  const categoryTemplates: Partial<Record<ProblemCategory, string>> = {\n    \"linked-lists\": `# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def ${functionName}(self, head: ListNode) -> ListNode:\n        # Your code here\n        pass\n`,\n    \"trees\": `# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def ${functionName}(self, root: TreeNode) -> any:\n        # Your code here\n        pass\n`,\n    \"graphs\": `from collections import defaultdict, deque\nfrom typing import List\n\nclass Solution:\n    def ${functionName}(self, n: int, edges: List[List[int]]) -> any:\n        # Build adjacency list\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        # Your code here\n        pass\n`,\n  };\n\n  return categoryTemplates[category] || `from typing import List, Optional\n\nclass Solution:\n    def ${functionName}(self, nums: List[int]) -> any:\n        # Your code here\n        pass\n`;\n}\n\nfunction getJavaScriptTemplate(title: string, category: ProblemCategory): string {\n  const functionName = toCamelCase(title);\n\n  const categoryTemplates: Partial<Record<ProblemCategory, string>> = {\n    \"linked-lists\": `/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar ${functionName} = function(head) {\n    // Your code here\n\n};\n`,\n    \"trees\": `/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * @param {TreeNode} root\n * @return {*}\n */\nvar ${functionName} = function(root) {\n    // Your code here\n\n};\n`,\n  };\n\n  return categoryTemplates[category] || `/**\n * @param {number[]} nums\n * @return {*}\n */\nvar ${functionName} = function(nums) {\n    // Your code here\n\n};\n`;\n}\n\nfunction getJavaTemplate(title: string, category: ProblemCategory): string {\n  const className = toPascalCase(title);\n  const methodName = toCamelCase(title);\n\n  const categoryTemplates: Partial<Record<ProblemCategory, string>> = {\n    \"linked-lists\": `/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode ${methodName}(ListNode head) {\n        // Your code here\n        return null;\n    }\n}\n`,\n    \"trees\": `/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public Object ${methodName}(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}\n`,\n  };\n\n  return categoryTemplates[category] || `import java.util.*;\n\nclass Solution {\n    public int[] ${methodName}(int[] nums) {\n        // Your code here\n        return new int[0];\n    }\n}\n`;\n}\n\nfunction getCppTemplate(title: string, category: ProblemCategory): string {\n  const functionName = toCamelCase(title);\n\n  const categoryTemplates: Partial<Record<ProblemCategory, string>> = {\n    \"linked-lists\": `/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* ${functionName}(ListNode* head) {\n        // Your code here\n        return nullptr;\n    }\n};\n`,\n    \"trees\": `/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void ${functionName}(TreeNode* root) {\n        // Your code here\n    }\n};\n`,\n  };\n\n  return categoryTemplates[category] || `#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> ${functionName}(vector<int>& nums) {\n        // Your code here\n        return {};\n    }\n};\n`;\n}\n\nfunction getCTemplate(title: string, category: ProblemCategory): string {\n  const functionName = toSnakeCase(title);\n\n  return `#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* ${functionName}(int* nums, int numsSize, int* returnSize) {\n    // Your code here\n    *returnSize = 0;\n    return NULL;\n}\n`;\n}\n\nfunction getCSharpTemplate(title: string, category: ProblemCategory): string {\n  const methodName = toPascalCase(title);\n\n  const categoryTemplates: Partial<Record<ProblemCategory, string>> = {\n    \"linked-lists\": `/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode ${methodName}(ListNode head) {\n        // Your code here\n        return null;\n    }\n}\n`,\n    \"trees\": `/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public object ${methodName}(TreeNode root) {\n        // Your code here\n        return null;\n    }\n}\n`,\n  };\n\n  return categoryTemplates[category] || `using System;\nusing System.Collections.Generic;\n\npublic class Solution {\n    public int[] ${methodName}(int[] nums) {\n        // Your code here\n        return new int[0];\n    }\n}\n`;\n}\n\nfunction getGoTemplate(title: string, category: ProblemCategory): string {\n  const functionName = toCamelCase(title);\n\n  const categoryTemplates: Partial<Record<ProblemCategory, string>> = {\n    \"linked-lists\": `/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc ${functionName}(head *ListNode) *ListNode {\n    // Your code here\n    return nil\n}\n`,\n    \"trees\": `/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc ${functionName}(root *TreeNode) interface{} {\n    // Your code here\n    return nil\n}\n`,\n  };\n\n  return categoryTemplates[category] || `func ${functionName}(nums []int) []int {\n    // Your code here\n    return nil\n}\n`;\n}\n\n// Helper functions to convert title to various case styles\nfunction toSnakeCase(str: string): string {\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"_\")\n    .replace(/^_|_$/g, \"\");\n}\n\nfunction toCamelCase(str: string): string {\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9]+(.)/g, (_, char) => char.toUpperCase())\n    .replace(/^./, (char) => char.toLowerCase())\n    .replace(/[^a-zA-Z0-9]/g, \"\");\n}\n\nfunction toPascalCase(str: string): string {\n  return str\n    .toLowerCase()\n    .replace(/[^a-z0-9]+(.)/g, (_, char) => char.toUpperCase())\n    .replace(/^./, (char) => char.toUpperCase())\n    .replace(/[^a-zA-Z0-9]/g, \"\");\n}\n\n/**\n * Generate all starter code templates for a problem\n */\nexport function getAllStarterTemplates(\n  problemTitle: string,\n  category: ProblemCategory\n): Record<SupportedLanguage, string> {\n  const languages: SupportedLanguage[] = [\n    \"python\",\n    \"javascript\",\n    \"java\",\n    \"cpp\",\n    \"c\",\n    \"csharp\",\n    \"go\",\n  ];\n\n  const templates: Record<string, string> = {};\n  for (const lang of languages) {\n    templates[lang] = getStarterTemplate(lang, problemTitle, category);\n  }\n\n  return templates as Record<SupportedLanguage, string>;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2226, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/coding/index.ts"],"sourcesContent":["// Coding Challenge Library - Main Exports\n\nexport * from \"./constants\";\nexport * from \"./problem-generator\";\nexport * from \"./code-evaluator\";\nexport * from \"./starter-templates\";\n"],"names":[],"mappings":";AAAA,0CAA0C;AAE1C;AACA;AACA;AACA"}},
    {"offset": {"line": 2246, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/redis.ts"],"sourcesContent":["/**\n * Redis Client using Upstash\n *\n * Provides a singleton Redis client for caching.\n * Falls back gracefully if Redis is not configured.\n */\n\nimport { Redis } from \"@upstash/redis\";\n\n// Cache key prefixes for organization\nexport const CACHE_KEYS = {\n  USER_ANALYTICS: \"analytics:user:\",\n  LEADERBOARD: \"leaderboard:\",\n  OLLAMA_HEALTH: \"ollama:health\",\n  INTERVIEW_QUESTIONS: \"questions:\",\n} as const;\n\n// TTL values in seconds\nexport const CACHE_TTL = {\n  USER_ANALYTICS: 5 * 60,      // 5 minutes\n  LEADERBOARD: 60,             // 1 minute\n  OLLAMA_HEALTH: 30,           // 30 seconds\n  INTERVIEW_QUESTIONS: 60 * 60, // 1 hour\n} as const;\n\n// Check if Redis is configured\nconst isRedisConfigured = () => {\n  return !!(\n    process.env.UPSTASH_REDIS_REST_URL &&\n    process.env.UPSTASH_REDIS_REST_TOKEN\n  );\n};\n\n// Create Redis client singleton\nlet redisClient: Redis | null = null;\n\nexport function getRedisClient(): Redis | null {\n  if (!isRedisConfigured()) {\n    return null;\n  }\n\n  if (!redisClient) {\n    redisClient = new Redis({\n      url: process.env.UPSTASH_REDIS_REST_URL!,\n      token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n    });\n  }\n\n  return redisClient;\n}\n\n// Helper to check if Redis is available\nexport function isRedisAvailable(): boolean {\n  return isRedisConfigured();\n}\n\nexport { Redis };\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;CAKC,GAED;;AAGO,MAAM,aAAa;IACxB,gBAAgB;IAChB,aAAa;IACb,eAAe;IACf,qBAAqB;AACvB;AAGO,MAAM,YAAY;IACvB,gBAAgB,IAAI;IACpB,aAAa;IACb,eAAe;IACf,qBAAqB,KAAK;AAC5B;AAEA,+BAA+B;AAC/B,MAAM,oBAAoB;IACxB,OAAO,CAAC,CAAC,CACP,QAAQ,GAAG,CAAC,sBAAsB,IAClC,QAAQ,GAAG,CAAC,wBAAwB,AACtC;AACF;AAEA,gCAAgC;AAChC,IAAI,cAA4B;AAEzB,SAAS;IACd,IAAI,CAAC,qBAAqB;QACxB,OAAO;IACT;IAEA,IAAI,CAAC,aAAa;QAChB,cAAc,IAAI,iPAAK,CAAC;YACtB,KAAK,QAAQ,GAAG,CAAC,sBAAsB;YACvC,OAAO,QAAQ,GAAG,CAAC,wBAAwB;QAC7C;IACF;IAEA,OAAO;AACT;AAGO,SAAS;IACd,OAAO;AACT"}},
    {"offset": {"line": 2301, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/lib/rate-limit.ts"],"sourcesContent":["/**\n * Rate Limiting Utility\n *\n * Sliding window rate limiter using Upstash Redis.\n * Falls back to in-memory storage when Redis is not configured.\n */\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getRedisClient, isRedisAvailable } from \"./redis\";\n\ninterface RateLimitConfig {\n  /** Maximum number of requests allowed in the window */\n  limit: number;\n  /** Time window in seconds */\n  window: number;\n}\n\ninterface RateLimitResult {\n  success: boolean;\n  limit: number;\n  remaining: number;\n  reset: number; // Unix timestamp when the window resets\n}\n\n// Predefined rate limit tiers\nexport const RATE_LIMITS = {\n  /** Auth routes (login, register) - strict to prevent brute force */\n  AUTH: { limit: 5, window: 60 },\n  /** Password change - very strict */\n  PASSWORD: { limit: 3, window: 60 },\n  /** Resource creation (interviews, challenges) - moderate */\n  CREATE: { limit: 10, window: 60 },\n  /** Chat/interaction endpoints - higher limit */\n  CHAT: { limit: 30, window: 60 },\n  /** Code submission - moderate */\n  SUBMIT: { limit: 20, window: 60 },\n  /** Read/list endpoints - generous */\n  READ: { limit: 60, window: 60 },\n  /** File upload - strict */\n  UPLOAD: { limit: 5, window: 60 },\n  /** AI/LLM endpoints (expensive) - moderate */\n  AI: { limit: 10, window: 60 },\n} as const;\n\n// In-memory fallback store\nconst memoryStore = new Map<string, { count: number; resetAt: number }>();\n\n// Clean up expired entries periodically\nsetInterval(() => {\n  const now = Date.now();\n  for (const [key, value] of memoryStore) {\n    if (value.resetAt <= now) {\n      memoryStore.delete(key);\n    }\n  }\n}, 60_000);\n\n/**\n * Extract client identifier from request.\n * Uses IP address for unauthenticated requests.\n */\nfunction getClientIp(request: NextRequest): string {\n  const forwarded = request.headers.get(\"x-forwarded-for\");\n  if (forwarded) {\n    return forwarded.split(\",\")[0].trim();\n  }\n  const realIp = request.headers.get(\"x-real-ip\");\n  if (realIp) {\n    return realIp;\n  }\n  return \"127.0.0.1\";\n}\n\n/**\n * Check rate limit using Redis sliding window.\n */\nasync function checkRedisRateLimit(\n  key: string,\n  config: RateLimitConfig\n): Promise<RateLimitResult> {\n  const redis = getRedisClient();\n  if (!redis) {\n    return { success: true, limit: config.limit, remaining: config.limit, reset: 0 };\n  }\n\n  const now = Date.now();\n  const windowMs = config.window * 1000;\n  const windowStart = now - windowMs;\n\n  // Use a sorted set for sliding window\n  const redisKey = `ratelimit:${key}`;\n\n  // Pipeline: remove old entries, add current, count, set expiry\n  const pipeline = redis.pipeline();\n  pipeline.zremrangebyscore(redisKey, 0, windowStart);\n  pipeline.zadd(redisKey, { score: now, member: `${now}:${Math.random()}` });\n  pipeline.zcard(redisKey);\n  pipeline.expire(redisKey, config.window);\n\n  const results = await pipeline.exec();\n  const count = (results[2] as number) || 0;\n\n  const reset = Math.ceil((now + windowMs) / 1000);\n  const remaining = Math.max(0, config.limit - count);\n  const success = count <= config.limit;\n\n  return { success, limit: config.limit, remaining, reset };\n}\n\n/**\n * Check rate limit using in-memory store (fallback).\n */\nfunction checkMemoryRateLimit(\n  key: string,\n  config: RateLimitConfig\n): RateLimitResult {\n  const now = Date.now();\n  const windowMs = config.window * 1000;\n  const storeKey = `ratelimit:${key}`;\n\n  const entry = memoryStore.get(storeKey);\n\n  if (!entry || entry.resetAt <= now) {\n    // New window\n    memoryStore.set(storeKey, { count: 1, resetAt: now + windowMs });\n    return {\n      success: true,\n      limit: config.limit,\n      remaining: config.limit - 1,\n      reset: Math.ceil((now + windowMs) / 1000),\n    };\n  }\n\n  entry.count++;\n  const remaining = Math.max(0, config.limit - entry.count);\n  const success = entry.count <= config.limit;\n\n  return {\n    success,\n    limit: config.limit,\n    remaining,\n    reset: Math.ceil(entry.resetAt / 1000),\n  };\n}\n\n/**\n * Core rate limit check. Returns result indicating if request is allowed.\n */\nexport async function checkRateLimit(\n  identifier: string,\n  config: RateLimitConfig\n): Promise<RateLimitResult> {\n  if (isRedisAvailable()) {\n    try {\n      return await checkRedisRateLimit(identifier, config);\n    } catch (error) {\n      console.error(\"Redis rate limit error, falling back to memory:\", error);\n      return checkMemoryRateLimit(identifier, config);\n    }\n  }\n  return checkMemoryRateLimit(identifier, config);\n}\n\n/**\n * Apply rate limiting to an API route handler.\n * Returns a 429 response if the limit is exceeded, or null if allowed.\n *\n * @param request - The incoming request\n * @param config - Rate limit configuration\n * @param keyPrefix - Prefix for the rate limit key (e.g., \"api:register\")\n * @param userId - Optional user ID for user-based limiting (falls back to IP)\n */\nexport async function rateLimit(\n  request: NextRequest,\n  config: RateLimitConfig,\n  keyPrefix: string,\n  userId?: string\n): Promise<NextResponse | null> {\n  const identifier = userId || getClientIp(request);\n  const key = `${keyPrefix}:${identifier}`;\n\n  const result = await checkRateLimit(key, config);\n\n  if (!result.success) {\n    const retryAfter = Math.max(1, result.reset - Math.ceil(Date.now() / 1000));\n    return NextResponse.json(\n      {\n        error: \"Too many requests\",\n        message: \"Rate limit exceeded. Please try again later.\",\n        retryAfter,\n      },\n      {\n        status: 429,\n        headers: {\n          \"Retry-After\": String(retryAfter),\n          \"X-RateLimit-Limit\": String(result.limit),\n          \"X-RateLimit-Remaining\": \"0\",\n          \"X-RateLimit-Reset\": String(result.reset),\n        },\n      }\n    );\n  }\n\n  return null;\n}\n\n/**\n * Add rate limit headers to a successful response.\n */\nexport function addRateLimitHeaders(\n  response: NextResponse,\n  result: RateLimitResult\n): NextResponse {\n  response.headers.set(\"X-RateLimit-Limit\", String(result.limit));\n  response.headers.set(\"X-RateLimit-Remaining\", String(result.remaining));\n  response.headers.set(\"X-RateLimit-Reset\", String(result.reset));\n  return response;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2492, "column": 0}, "map": {"version":3,"sources":["file:///Users/sairammaruri/Documents/Git/system-design/system-design-simulator/src/app/api/coding/challenge/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { auth } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/prisma\";\nimport {\n  generateCodingProblem,\n  getStarterTemplate,\n  TIME_LIMITS,\n  DifficultyLevel,\n  ProblemCategory,\n  SupportedLanguage,\n  SUPPORTED_LANGUAGES,\n  PROBLEM_CATEGORIES,\n  DIFFICULTY_LEVELS,\n} from \"@/lib/coding\";\nimport { rateLimit, RATE_LIMITS } from \"@/lib/rate-limit\";\n\n// POST /api/coding/challenge - Create a new coding challenge\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await auth();\n\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n    }\n\n    const rateLimitResponse = await rateLimit(request, RATE_LIMITS.CREATE, \"api:coding:challenge:create\", session.user.id);\n    if (rateLimitResponse) return rateLimitResponse;\n\n    const body = await request.json();\n    const {\n      difficulty,\n      category,\n      company,\n      language,\n      problemId, // Optional: use predefined problem\n      generatedProblem, // Optional: use pre-generated problem from preview\n    } = body;\n\n    // Validate required fields\n    if (!difficulty || !category || !language) {\n      return NextResponse.json(\n        { error: \"Difficulty, category, and language are required\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate difficulty\n    if (!DIFFICULTY_LEVELS.includes(difficulty as DifficultyLevel)) {\n      return NextResponse.json(\n        { error: \"Invalid difficulty level\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate category\n    if (!PROBLEM_CATEGORIES.includes(category as ProblemCategory)) {\n      return NextResponse.json(\n        { error: \"Invalid category\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate language\n    if (!(language in SUPPORTED_LANGUAGES)) {\n      return NextResponse.json(\n        { error: \"Invalid language\" },\n        { status: 400 }\n      );\n    }\n\n    let problemData;\n    let predefinedProblem = null;\n\n    // Use pre-generated problem, predefined problem, or generate new one\n    if (generatedProblem) {\n      // Use the pre-generated problem from the preview API\n      const fullDescription = formatFullDescription({\n        title: generatedProblem.title,\n        description: generatedProblem.description,\n        constraints: generatedProblem.constraints || [],\n        examples: generatedProblem.examples || [],\n      });\n\n      problemData = {\n        title: generatedProblem.title,\n        description: fullDescription,\n        visibleTestCases: generatedProblem.visibleTestCases,\n        hiddenTestCases: generatedProblem.hiddenTestCases,\n        starterCode: generatedProblem.starterCode,\n      };\n    } else if (problemId) {\n      predefinedProblem = await prisma.codingProblem.findUnique({\n        where: { id: problemId },\n      });\n\n      if (!predefinedProblem) {\n        return NextResponse.json(\n          { error: \"Problem not found\" },\n          { status: 404 }\n        );\n      }\n\n      problemData = {\n        title: predefinedProblem.title,\n        description: predefinedProblem.description,\n        visibleTestCases: JSON.parse(predefinedProblem.testCases).filter(\n          (tc: { isHidden?: boolean }) => !tc.isHidden\n        ),\n        hiddenTestCases: JSON.parse(predefinedProblem.testCases).filter(\n          (tc: { isHidden?: boolean }) => tc.isHidden\n        ),\n        starterCode: JSON.parse(predefinedProblem.starterCode)[language],\n      };\n    } else {\n      // Generate new problem using Llama\n      const newProblem = await generateCodingProblem({\n        difficulty: difficulty as DifficultyLevel,\n        category: category as ProblemCategory,\n        company,\n      });\n\n      // Get starter code for the selected language\n      const starterCode = getStarterTemplate(\n        language as SupportedLanguage,\n        newProblem.title,\n        category as ProblemCategory\n      );\n\n      // Format full description with constraints and examples\n      const fullDescription = formatFullDescription(newProblem);\n\n      problemData = {\n        title: newProblem.title,\n        description: fullDescription,\n        visibleTestCases: newProblem.visibleTestCases,\n        hiddenTestCases: newProblem.hiddenTestCases,\n        starterCode,\n      };\n    }\n\n    // Create the challenge\n    const challenge = await prisma.codingChallenge.create({\n      data: {\n        userId: session.user.id,\n        problemId: predefinedProblem?.id || null,\n        title: problemData.title,\n        description: problemData.description,\n        difficulty,\n        category,\n        company: company || null,\n        language,\n        visibleTests: JSON.stringify(problemData.visibleTestCases),\n        hiddenTests: JSON.stringify(problemData.hiddenTestCases),\n        timeLimit: TIME_LIMITS[difficulty as DifficultyLevel],\n        status: \"pending\",\n        starterCode: problemData.starterCode,\n      },\n    });\n\n    return NextResponse.json({\n      challenge: {\n        id: challenge.id,\n        title: challenge.title,\n        description: challenge.description,\n        difficulty: challenge.difficulty,\n        category: challenge.category,\n        company: challenge.company,\n        language: challenge.language,\n        timeLimit: challenge.timeLimit,\n        status: challenge.status,\n        starterCode: challenge.starterCode,\n        visibleTests: JSON.parse(challenge.visibleTests),\n      },\n    });\n  } catch (error) {\n    console.error(\"Challenge creation error:\", error);\n    return NextResponse.json(\n      { error: \"Failed to create challenge. Please try again.\" },\n      { status: 500 }\n    );\n  }\n}\n\n// GET /api/coding/challenge - List user's challenges\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await auth();\n\n    if (!session?.user?.id) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n    }\n\n    const rateLimitResponse = await rateLimit(request, RATE_LIMITS.READ, \"api:coding:challenge:list\", session.user.id);\n    if (rateLimitResponse) return rateLimitResponse;\n\n    const challenges = await prisma.codingChallenge.findMany({\n      where: { userId: session.user.id },\n      orderBy: { createdAt: \"desc\" },\n      include: { score: true },\n    });\n\n    const formattedChallenges = challenges.map((c) => ({\n      id: c.id,\n      title: c.title,\n      difficulty: c.difficulty,\n      category: c.category,\n      company: c.company,\n      language: c.language,\n      status: c.status,\n      timeLimit: c.timeLimit,\n      startedAt: c.startedAt,\n      endedAt: c.endedAt,\n      createdAt: c.createdAt,\n      score: c.score\n        ? {\n            overallScore: c.score.overallScore,\n            passStatus: c.score.passStatus,\n          }\n        : null,\n    }));\n\n    return NextResponse.json({ challenges: formattedChallenges });\n  } catch (error) {\n    console.error(\"Challenge fetch error:\", error);\n    return NextResponse.json(\n      { error: \"Internal server error\" },\n      { status: 500 }\n    );\n  }\n}\n\n// Helper function to format the full problem description\nfunction formatFullDescription(problem: {\n  title: string;\n  description: string;\n  constraints: string[];\n  examples: { input: string; output: string; explanation?: string }[];\n}): string {\n  let description = `${problem.description}\\n\\n`;\n\n  if (problem.constraints.length > 0) {\n    description += `**Constraints:**\\n`;\n    problem.constraints.forEach((c) => {\n      description += `- ${c}\\n`;\n    });\n    description += \"\\n\";\n  }\n\n  if (problem.examples.length > 0) {\n    description += `**Examples:**\\n\\n`;\n    problem.examples.forEach((ex, i) => {\n      description += `**Example ${i + 1}:**\\n`;\n      description += `- Input: \\`${ex.input}\\`\\n`;\n      description += `- Output: \\`${ex.output}\\`\\n`;\n      if (ex.explanation) {\n        description += `- Explanation: ${ex.explanation}\\n`;\n      }\n      description += \"\\n\";\n    });\n  }\n\n  return description;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAWA;;;;;;;;;;;AAGO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,qMAAI;QAE1B,IAAI,CAAC,SAAS,MAAM,IAAI;YACtB,OAAO,yNAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,oBAAoB,MAAM,IAAA,mNAAS,EAAC,SAAS,qNAAW,CAAC,MAAM,EAAE,+BAA+B,QAAQ,IAAI,CAAC,EAAE;QACrH,IAAI,mBAAmB,OAAO;QAE9B,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EACJ,UAAU,EACV,QAAQ,EACR,OAAO,EACP,QAAQ,EACR,SAAS,EACT,gBAAgB,EACjB,GAAG;QAEJ,2BAA2B;QAC3B,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,UAAU;YACzC,OAAO,yNAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkD,GAC3D;gBAAE,QAAQ;YAAI;QAElB;QAEA,sBAAsB;QACtB,IAAI,CAAC,iOAAiB,CAAC,QAAQ,CAAC,aAAgC;YAC9D,OAAO,yNAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA2B,GACpC;gBAAE,QAAQ;YAAI;QAElB;QAEA,oBAAoB;QACpB,IAAI,CAAC,kOAAkB,CAAC,QAAQ,CAAC,WAA8B;YAC7D,OAAO,yNAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmB,GAC5B;gBAAE,QAAQ;YAAI;QAElB;QAEA,oBAAoB;QACpB,IAAI,CAAC,CAAC,YAAY,mOAAmB,GAAG;YACtC,OAAO,yNAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmB,GAC5B;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI;QACJ,IAAI,oBAAoB;QAExB,qEAAqE;QACrE,IAAI,kBAAkB;YACpB,qDAAqD;YACrD,MAAM,kBAAkB,sBAAsB;gBAC5C,OAAO,iBAAiB,KAAK;gBAC7B,aAAa,iBAAiB,WAAW;gBACzC,aAAa,iBAAiB,WAAW,IAAI,EAAE;gBAC/C,UAAU,iBAAiB,QAAQ,IAAI,EAAE;YAC3C;YAEA,cAAc;gBACZ,OAAO,iBAAiB,KAAK;gBAC7B,aAAa;gBACb,kBAAkB,iBAAiB,gBAAgB;gBACnD,iBAAiB,iBAAiB,eAAe;gBACjD,aAAa,iBAAiB,WAAW;YAC3C;QACF,OAAO,IAAI,WAAW;YACpB,oBAAoB,MAAM,yMAAM,CAAC,aAAa,CAAC,UAAU,CAAC;gBACxD,OAAO;oBAAE,IAAI;gBAAU;YACzB;YAEA,IAAI,CAAC,mBAAmB;gBACtB,OAAO,yNAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;gBAAoB,GAC7B;oBAAE,QAAQ;gBAAI;YAElB;YAEA,cAAc;gBACZ,OAAO,kBAAkB,KAAK;gBAC9B,aAAa,kBAAkB,WAAW;gBAC1C,kBAAkB,KAAK,KAAK,CAAC,kBAAkB,SAAS,EAAE,MAAM,CAC9D,CAAC,KAA+B,CAAC,GAAG,QAAQ;gBAE9C,iBAAiB,KAAK,KAAK,CAAC,kBAAkB,SAAS,EAAE,MAAM,CAC7D,CAAC,KAA+B,GAAG,QAAQ;gBAE7C,aAAa,KAAK,KAAK,CAAC,kBAAkB,WAAW,CAAC,CAAC,SAAS;YAClE;QACF,OAAO;YACL,mCAAmC;YACnC,MAAM,aAAa,MAAM,IAAA,gPAAqB,EAAC;gBAC7C,YAAY;gBACZ,UAAU;gBACV;YACF;YAEA,6CAA6C;YAC7C,MAAM,cAAc,IAAA,6OAAkB,EACpC,UACA,WAAW,KAAK,EAChB;YAGF,wDAAwD;YACxD,MAAM,kBAAkB,sBAAsB;YAE9C,cAAc;gBACZ,OAAO,WAAW,KAAK;gBACvB,aAAa;gBACb,kBAAkB,WAAW,gBAAgB;gBAC7C,iBAAiB,WAAW,eAAe;gBAC3C;YACF;QACF;QAEA,uBAAuB;QACvB,MAAM,YAAY,MAAM,yMAAM,CAAC,eAAe,CAAC,MAAM,CAAC;YACpD,MAAM;gBACJ,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,WAAW,mBAAmB,MAAM;gBACpC,OAAO,YAAY,KAAK;gBACxB,aAAa,YAAY,WAAW;gBACpC;gBACA;gBACA,SAAS,WAAW;gBACpB;gBACA,cAAc,KAAK,SAAS,CAAC,YAAY,gBAAgB;gBACzD,aAAa,KAAK,SAAS,CAAC,YAAY,eAAe;gBACvD,WAAW,2NAAW,CAAC,WAA8B;gBACrD,QAAQ;gBACR,aAAa,YAAY,WAAW;YACtC;QACF;QAEA,OAAO,yNAAY,CAAC,IAAI,CAAC;YACvB,WAAW;gBACT,IAAI,UAAU,EAAE;gBAChB,OAAO,UAAU,KAAK;gBACtB,aAAa,UAAU,WAAW;gBAClC,YAAY,UAAU,UAAU;gBAChC,UAAU,UAAU,QAAQ;gBAC5B,SAAS,UAAU,OAAO;gBAC1B,UAAU,UAAU,QAAQ;gBAC5B,WAAW,UAAU,SAAS;gBAC9B,QAAQ,UAAU,MAAM;gBACxB,aAAa,UAAU,WAAW;gBAClC,cAAc,KAAK,KAAK,CAAC,UAAU,YAAY;YACjD;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,yNAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAgD,GACzD;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,qMAAI;QAE1B,IAAI,CAAC,SAAS,MAAM,IAAI;YACtB,OAAO,yNAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,oBAAoB,MAAM,IAAA,mNAAS,EAAC,SAAS,qNAAW,CAAC,IAAI,EAAE,6BAA6B,QAAQ,IAAI,CAAC,EAAE;QACjH,IAAI,mBAAmB,OAAO;QAE9B,MAAM,aAAa,MAAM,yMAAM,CAAC,eAAe,CAAC,QAAQ,CAAC;YACvD,OAAO;gBAAE,QAAQ,QAAQ,IAAI,CAAC,EAAE;YAAC;YACjC,SAAS;gBAAE,WAAW;YAAO;YAC7B,SAAS;gBAAE,OAAO;YAAK;QACzB;QAEA,MAAM,sBAAsB,WAAW,GAAG,CAAC,CAAC,IAAM,CAAC;gBACjD,IAAI,EAAE,EAAE;gBACR,OAAO,EAAE,KAAK;gBACd,YAAY,EAAE,UAAU;gBACxB,UAAU,EAAE,QAAQ;gBACpB,SAAS,EAAE,OAAO;gBAClB,UAAU,EAAE,QAAQ;gBACpB,QAAQ,EAAE,MAAM;gBAChB,WAAW,EAAE,SAAS;gBACtB,WAAW,EAAE,SAAS;gBACtB,SAAS,EAAE,OAAO;gBAClB,WAAW,EAAE,SAAS;gBACtB,OAAO,EAAE,KAAK,GACV;oBACE,cAAc,EAAE,KAAK,CAAC,YAAY;oBAClC,YAAY,EAAE,KAAK,CAAC,UAAU;gBAChC,IACA;YACN,CAAC;QAED,OAAO,yNAAY,CAAC,IAAI,CAAC;YAAE,YAAY;QAAoB;IAC7D,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,yNAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEA,yDAAyD;AACzD,SAAS,sBAAsB,OAK9B;IACC,IAAI,cAAc,GAAG,QAAQ,WAAW,CAAC,IAAI,CAAC;IAE9C,IAAI,QAAQ,WAAW,CAAC,MAAM,GAAG,GAAG;QAClC,eAAe,CAAC,kBAAkB,CAAC;QACnC,QAAQ,WAAW,CAAC,OAAO,CAAC,CAAC;YAC3B,eAAe,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC;QAC3B;QACA,eAAe;IACjB;IAEA,IAAI,QAAQ,QAAQ,CAAC,MAAM,GAAG,GAAG;QAC/B,eAAe,CAAC,iBAAiB,CAAC;QAClC,QAAQ,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI;YAC5B,eAAe,CAAC,UAAU,EAAE,IAAI,EAAE,KAAK,CAAC;YACxC,eAAe,CAAC,WAAW,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC;YAC3C,eAAe,CAAC,YAAY,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC;YAC7C,IAAI,GAAG,WAAW,EAAE;gBAClB,eAAe,CAAC,eAAe,EAAE,GAAG,WAAW,CAAC,EAAE,CAAC;YACrD;YACA,eAAe;QACjB;IACF;IAEA,OAAO;AACT"}}]
}